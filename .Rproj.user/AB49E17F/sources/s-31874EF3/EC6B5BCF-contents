# clean up the memory from previous R calculations

rm(list=ls())

#Set the working directory
setwd("G:/Data/Petros Pechlivanoglou/Projects/Decision modelling in R/Markov models in R")

##### introduce the parameters in line in the script
#first we install and load the libraraies that we will be using throughout:

library(abind)
# We continue by loading the input parameters to be estimated
pars=read.table("Input_markov.txt",header=T,dec=",")
# pars=read.table("/Users/FAE/Google Drive/Projects/DA_R/Articles/Microsimulation/R code/Input_markov.txt",header=T,dec=",")
tpProg <- tpProg
#attach the parameters. The attach function breaks down the data frame columnwise into seperate variables
attach(pars)


#### Initialize the variables that will be used#####
#There are five dimensions that are important in a microsimulation,
#especially with respect to the specifing the size of variables in teh model:
#1. the number of patients that are going to be simulated at every solution of the model
#2, the number of iterations of the model to test for second order uncertainty (in the probabilistic scenario)
#3. the number of cycles (months years etc) that the hypothetical patients will be followed up in the model.
#4. the number of alternative treatment strategies.
#5. The number of events we are interested in capturing
# the value of these three parameters indicate also the level of computational complexity of the model

# specify the the number of hypthetical patients for every microsimulation
N=100000

#specify the number of cycles : in this case we define the cycles as the number of years
#between the maximum age we are willing to follow up the patients and the initial age they are 
#introduced in the mdoel, We divide by a constant "cycle" to allow for cycles that are smaller (if cycle>1) or 
#larger (if cycle>1) than the year.
nc <- (max_age-ini_age)/cycle

# In this example we are only interested for two treatment alternatives: standard of care and the (new) treatment
# Below we create vectors with the names and number of treatment strategies

txs <- c("Usual Care", "New Treatment")
nt <- length(txs)

# here we estimate the discount factor. The discount factor is the inverse of the discount weight
# When the time will come that we have esimated the total outcomes (health and cost) for every cycle
# we will divide the outcome with the discount factor
disc_o=(1+oDR)^(0:(nc-1))
disc_c=(1+cDR)^(0:(nc-1))

# The annual probability of natural death was provided in 10 year intervals. This is sometimes called an
#abridged table.We need to create a vector of size ncx1 that will capture the annual probility of natural
# death for every cycle in the model. A simple way to do so it to replicate the annual probabilies
# for 10 year intevals. A more sophisticated approach would be to rely on smoothing methods that can
# interpolate the values and thus create a continuous vector of probabilities. 

nD = c(rep(nD55,10),rep(nD65,10),rep(nD75,10),rep(nD85,15),1)


#provide names on the vector of annual probability of natural death 
names(nD) <- ini_age : max_age

# As you recall the conceptual model included four  states: Progression free, progression, natural death and disease related death'
# in a state-tranistion model the cohort of patients are assumed to be transitioning across states. In a microsimulation approach what is of interest is to 
# capture the events that occur over the time horizon that individuals are followed up. Probabilities of future events might be dependent on the occurance of 
# these events in the past and capturing these events in variables is one way of adding memory to the model. 
# Below we create vectors with the names and number of the events we are interested in capturing

events <- c("Prog", "Natural Death", "Disease Death")
n_events <- length(events)

# we need to initialize the multidimentional arrays that will capture the probabilities of experiencing the events as well as
# the realizations of these effects. We create three arrays with sizes equal to the number of events of interest, 
# size of microsimulation, number of cycles and number of treatments: 
# the variable Probs captures the probabilities for each event to occur at  cycle t
# the variable Events captures whether the event actually happened at  cycle t.
# the variable C_Events captures whether the event has happened at any point in the past up to (and including )  cycle t.  

Probs <-Events <- C_Events <- array(0, dim=c(n_events, N, nc, nt))

# We provide the names for the dimensions of the variabels we have created

dimnames(Events)[[1]] <- dimnames(Probs)[[1]] <- dimnames(C_Events)[[1]] <- events
dimnames(Events)[[4]] <- dimnames(Probs)[[4]] <- dimnames(C_Events)[[4]] <- txs 

# As mentioned, individuals in this microsimulation are at risk of experiencing an event at every cycle.
# They therefore have an underlying probability of an event to occur.  Whether the event actually
# occurs in that cycle is uncertain. In this p[articular example we have two types of events: 
# The event of progression can occur to anyone that is alive and not progressed. Therefore every individual has 
# a binomial probability of an event to occur. Below we create a function that estimates whether the event occured at
# every cycle
real_binom <- function(x){
  rbinom(length(x), 1, x)
}

# The other two events are natural death and disease-specific death. Given that these two events are mutually exclusive
# We used a multinomial distribution to  estimate the "realization" of these events at every cycle.
# we do that in two steps: 
#first we create a function that generates three realizations from a multinomial distribution: 
#any individual can either die from natural disease, from disease specific disease or remain alive.
# y captures the probabilities of natural and disease specific death 
real_multi <- function(y){
  rmultinom(1, 1, c(y, 1-sum(y)))
}

# we are now ready to run our microsimulation for nc cycles. Remember that for every cycle we need to update the probabilities of events,
# the array with the events that occured on the cycle and finally update the matrix that captures whether individuals ever had 
# each of these events up until that particular cycle.
# we assume that cycle 0 occures when i = 1 since we can't  have an index 0 in R. Hence, at i = 1  noone had any event and everyone was alive

for (i in 2:nc) {
# the probabilities are dependent on  whether individuals are on treatment or 
# not  as well as on whether they have experienced progression. 
# initially we assign a probability of progression to the treatment and control 
# accordingly.  We also assume that the probability of death is equal
# to that of natural death. We will update these probabilities in the next step 
# for those that have already progressed. Finally, remember that the 
# probability of progression increases every year (that's why we multiply by  i-1). 
# Remember that R is filling in the matrix over columns. 
	Probs[, , i, 1] <- c(tpProg * (i-1), nD[i], 0)
	Probs[, , i, 2] <- c(tpProg * effect * (i-1), nD[i], 0)
	
# Below we create some help variables to identify the indicators (column/row #) 
# of individuals who have a history of prior events
	
	C_Prog1 <- which(C_Events["Prog" , , i-1, 1] == 1, arr.ind = T)
	C_nD1   <- which(C_Events["Natural Death", , i-1, 1] == 1, arr.ind = T)
  C_dD1   <- which(C_Events["Disease Death", , i-1, 1] == 1, arr.ind = T)

  C_Prog2 <- which(C_Events["Prog" , , i-1, 2] == 1, arr.ind = T)
  C_nD2   <- which(C_Events["Natural Death", , i-1, 2] == 1, arr.ind = T)
  C_dD2   <- which(C_Events["Disease Death", , i-1, 2] == 1, arr.ind = T)
  
# we replace the probability of death due to disease from zero to tpDcm for 
# those individuals that have experienced disease progression.   
	Probs[3, C_Prog1, i , 1] <- tpDcm
	Probs[1, C_Prog1, i , 1] <- 0
	Probs[3, C_Prog2, i , 2] <- tpDcm
	Probs[1, C_Prog2, i , 2] <- 0
	
	
# For those that have died replace all probabilities of events with zero, as 
# they are not at risk of experiencing an event. 
	Probs[, C_nD1, i, 1] <- 0
	Probs[, C_dD1, i, 1] <- 0
	Probs[, C_nD2, i, 2] <- 0
	Probs[, C_dD2, i, 2] <- 0
	
	
# keep track of individuals experiencing events at time t. 
#	The probability of experiencing an event is translated in a realization 
# from the binomial or multinomial distribition
	Events[1, , i, 1] <- rbinom(N,1,Probs[1, , i, 1])
	Events[1, , i, 2] <- rbinom(N,1,Probs[1, , i, 2])
	
	Events[2:3, , i,] <- apply(Probs[2:3, , i, ], 2:3, real_multi)[1:2,,]
	
# update the cumulative events array depending on whether the event happened 
# at time t	
	C_Events[, , i, ] <- C_Events[, , i-1, ]
	C_Events[, , i, ][Events[, , i,] == 1] <- 1
}

# We assign the cost of being on the assymptomatic state to everyone since 
# everyone starts from there

Costs <- array(cAsymp, dim=c(N, nc, 2))

# the cost of drug is assigned to the treatment group
Costs [,,2] <- Costs [,,2]+ cDrug
# We assign the cost of progression to those that progressed at some point in their lifetime. 
Costs[C_Events["Prog", , ,] == 1] <- cProg

# We set costs to zero for those that died (from death to end of follow up)
Costs[C_Events["Natural Death", , ,] == 1] <- 0
Costs[C_Events["Disease Death", , ,] == 1] <- 0

# add the cost of Natural death to those that die by the disease
Costs[Events["Disease Death", , ,] == 1] <- cDeath

# similarly for utilities assign to eveyone the utility of asymptomatic
QALY <- array(uAsymp, dim=c(N, nc,2))

# We set utilities of the progressed to uProg and those that died to zero

QALY[C_Events["Prog", , ,] == 1] <- uProg
QALY[C_Events["Natural Death", , ,] == 1] <- 0
QALY[C_Events["Disease Death", , ,] == 1] <- 0



C <- apply((cbind(apply(Costs[,,1],2,sum), apply(Costs[,,2],2,sum)) / disc_c),2,sum) / N

E <- apply((cbind(apply(QALY[,,1],2,sum), apply(QALY[,,2],2,sum)) / disc_c), 2, sum) / N



#calculate lifelong per patient discounted cost and QALYs.

#Calculate incremental costs and effects and ICERs

DC=C[2]-C[1]
names(DC)="Incremental costs"
DE=E[2]-E[1]
names(DE)="QALYs gained"
ICER=DC/DE
names(ICER)="ICER"
results=c(DC,DE,ICER)

#create full incremental cost-effectiveness analysis table 
Costs=round(C,2)
Effects=round(E,2)

Strategies=c("Control","Treatment")
DC=c("",as.character(round(DC,2)))
DE=c("",as.character(round(DE,2)))
ICER=c("",as.character(round(ICER,2)))

table=cbind(Strategies,Costs,Effects,DC,DE,ICER)
table=as.data.frame(table)
write.table(table,"table.txt")


