############################################################################################
################# Microsimulation modeling using R: a tutorial #### 2017 ###################
############################################################################################
# This code forms the basis for the microsimulation model of the article: 
# 'Microsimulation modeling for health decision sciences using R: a tutorial' 
# Authors: Eline Krijkamp, Fernando Alarid-Escudero, 
#          Eva Enns, Hawre Jalal, Myriam Hunink and  Petros Pechlivanoglou
# Please cite the article when using this code
#
# To program this tutorial we made use of 
# R: 3.3.0 GUI 1.68 Mavericks build (7202)
# RStudio: Version 1.0.136 2009-2016 RStudio, Inc.

############################################################################################
################# Code of Appendix A #######################################################
############################################################################################
#rm(list = ls())  # remove any variables in R's memory 

##################################### Model input #########################################

# Model input
n.i   <- 100000                  # number of simulated individuals
n.t   <- 30                      # time horizon, 30 cycles
v.M_1 <- rep("H", n.i)           # everyone begins in the healthy state at cycle 1
v.n   <- c("H","S1","S2","D")    # the 4 states of the model: Healthy, Sick, Sicker, Dead
n.s   <- length(v.n)             # the number of health states
d.c   <- d.e <- 0.03             # equal discounting of costs and QALYs by 3%
seed  <- 1                       # set a seed value for the random number generator
v.Trt <- c("No Treatment", "Treatment") # store the strategy names

# Transition probabilities (per cycle)
p.HD    <- 0.005             # probability to die when healthy
p.HS1   <- 0.15          	   # probability to become sick when healthy
p.S1H   <- 0.5           	   # probability to become healthy when sick
p.S1S2  <- 0.105         	   # probability to become sicker when sick
rr.S1   <- 3             	   # Rate ratio of death in S1 vs healthy
rr.S2   <- 10            	   # Rate ratio of death in S2 vs healthy 
r.HD    <- -log(1 - p.HD) 	 # rate of death in H 
r.S1D   <- rr.S1 * r.HD  	   # rate of death in S1
r.S2D   <- rr.S2 * r.HD  	   # rate of death in S2
p.S1D   <- 1 - exp(-r.S1D)   # probability to die in S1
p.S2D   <- 1 - exp(-r.S2D)   # probability to die in S2

# Cost and utility inputs 
c.H     <- 2000              # cost of remaining one cycle in state H
c.S1    <- 4000              # cost of remaining one cycle in state S1
c.S2    <- 15000             # cost of remaining one cycle in state S2
c.Trt   <- 12000             # cost of treatment(per cycle)

u.H     <- 1                 # utility when healthy (H)
u.S1    <- 0.75              # utility when sick (S1)
u.S2    <- 0.5               # utility when sicker (S2)
u.Trt   <- 0.95              # utility when being treated (Trt)


##################################### Functions ###########################################

# The MicroSim function for the simple microsimulation of the 'Sick-Sicker' model keeps track of what happens to each individual during each cycle. 

MicroSim <- function(v.M_1, n.i, n.t, v.n, d.c, d.e, TR.out = TRUE, TS.out = TRUE, Trt = FALSE, seed = 1) {
# Arguments:  
  # v.M_1:   vector of initial states for individuals
  # n.i:     number of individuals
  # n.t:     total number of cycles to run the model
  # v.n:     vector of health state names
  # d.c:     discount rate for costs
  # d.e:     discount rate for health outcome (QALYs)
  # TR.out:  should the output include a Microsimulation trace? (default is TRUE)
  # TS.out:  should the output include a transition array between states? (default is TRUE)
  # Trt:     are the individuals receiving treatment? (default scalar Boolean value is FALSE)
  # seed:    starting seed number for random number generator (default is 1)
# Makes use of:
  # Probs:   function for the estimation of transition probabilities
  # Costs:   function for the estimation of cost state values
  # Effs:    function for the estimation of state specific health outcomes (QALYs)
 
  
  v.dwc <- 1 / (1 + d.c) ^ (0:(n.t - 1))   # calculate the cost discount weight based on the discount rate d.c 
  v.dwe <- 1 / (1 + d.e) ^ (0:(n.t - 1))   # calculate the QALY discount weight based on the discount rate d.e
  
 # Create the matrix capturing the state name/costs/health outcomes for all individuals at each time point 
  
  m.M <- m.C <- m.E <-  matrix(nrow = n.i, ncol = n.t, 
                               dimnames = list(paste("ind", 1:n.i, sep = " "), 
                                               paste("cycle", 1:n.t, sep = " ")))  
  
  m.M[, 1] <- v.M_1                     # Indicate the initial health state at cycle 1   
  
  for (i in 1:n.i) {
    set.seed(seed + i)                  # set the seed for every individual   
    m.C[i, 1] <- Costs(m.M[i, 1], Trt)  # estimate costs per individual during cycle 1
    m.E[i, 1] <- Effs (m.M[i, 1], Trt)  # estimate QALYs per individual during cycle 1
    v.p       <- Probs(m.M[i, 1])       # calculate the transition probabilities at the end of cycle 1
    
    for (t in 2:n.t) {
      m.M[i, t] <- sample(v.n, prob = v.p, size = 1)  # sample the current health state and store that state in matrix m.M 
      m.C[i, t] <- Costs(m.M[i, t], Trt)   # estimate costs per individual during cycle t
      m.E[i, t] <- Effs(m.M[i, t], Trt)    # estimate QALYs per individual during cycle t

      v.p <- Probs(m.M[i, t])              # calculate the transition probabilities for cycle t + 1 at the end of cycle t
      
    } # close the loop for the time points 
  } # close the loop for the individuals 
  
  tc <- m.C %*% v.dwc       # total discounted cost per individual
  te <- m.E %*% v.dwe       # total discounted QALYs per individual 
  
  tc_hat <- mean(tc)        # average discounted cost 
  te_hat <- mean(te)        # average discounted QALYs

  if (TS.out == TRUE) {  # create a  matrix of transitions across states
    TS <- paste(m.M, cbind(m.M[, -1], NA), sep = "->") # Transitions from one state to the other
    TS <- matrix(TS, nrow = n.i)
    colnames(TS) <- paste("Cycle", 1:n.t, sep = " ")    # name the columns of the matrix
    rownames(TS) <- paste("Ind", 1:n.i, sep = " ")      # name the rows of the matrix
  } else {
    TS <- NULL
  }
  if (TR.out == TRUE) {
    TR <- t(apply(m.M, 2, function(x) table(factor(x, levels = v.n, ordered = TRUE))))
    TR <- TR / n.i                                       # create a distribution trace
    colnames(TR) <- v.n                                  # name the rows of the matrix
    rownames(TR) <- paste("Cycle", 1:n.t, sep = " ")     # name the columns of the matrix
  } else {
    TR <- NULL
  }
  results <- list(m.M = m.M, m.C = m.C, m.E = m.E, tc = tc, te = te, tc_hat = tc_hat, te_hat = te_hat, TS = TS, TR = TR) # store the results from the simulation in a list  
  return(results)  # return the results
}  # end of the MicroSim function  


#### Probability function
# The Probs function updates the transition probabilities of every cycle is shown below.

Probs <- function(M_it) { 
  # M_it:    health state occupied by individual i at cycle t

  v.p.it <- rep(NA, length(v.n))     # create vector of state transition probabilities
  names(v.p.it) <- v.n               # assign names to the vector
  
  # update the v.p with the appropriate probabilities   
  v.p.it[M_it == "H"]  <- c(1 - p.HS1 - p.HD, p.HS1, 0, p.HD)                  # transition probabilities when in H
  v.p.it[M_it == "S1"] <- c(p.S1H, 1- p.S1H - p.S1S2 - p.S1D, p.S1S2, p.S1D)   # transition probabilities when in S1
  v.p.it[M_it == "S2"] <- c(0, 0, 1 - p.S2D, p.S2D)                            # transition probabilities when in S2
  v.p.it[M_it == "D"]  <- c(0, 0, 0, 1)                                        # transition probabilities when dead      
  ifelse(sum(v.p.it) == 1, return(v.p.it), print("Probabilities do not sum to 1")) # return the transition probabilities or produce an error
}       


### Costs function
# The  Costs function estimates the costs at every cycle.

Costs <- function (M_it, Trt = FALSE) {
  # M_it: health state occupied by individual i at cycle t
  # Trt:  is the individual being treated? (default is FALSE) 
  c.it <- 0                                  # assign the cost of being dead
  c.it[M_it == "H"]  <- c.H                  # assign the cost of being healthy
  c.it[M_it == "S1"] <- c.S1 + c.Trt * Trt   # assign the cost of S1
  c.it[M_it == "S2"] <- c.S2 + c.Trt * Trt   # assign the cost of S2
  return(c.it)        		                   # return the costs
}


### Health outcome function 
# The Effs function to update the utilities at every cycle for the extended microsimulaton.

Effs <- function (M_it, Trt = FALSE, cl = 1) {
  # M_it: health state occupied by individual i at cycle t
  # Trt:  is the individual treated? (default is FALSE) 
  # cl:   cycle length (default is 1)
  u.it <- 0                      # by default the utility for everyone is zero
  u.it[M_it == "H"]  <- u.H      # assign the utility of being healthy
  u.it[M_it == "S1"] <- Trt * u.Trt + (1 - Trt) * u.S1  # for those treated, utility is equal to u.Trt while for those not treated is u.S1
  u.it[M_it == "S2"] <- u.S2     # assign the utility of being in S2
  QALYs <-  u.it * cl            # calculate the QALYs during cycle t
  return(QALYs)                  # return the QALYs
}


##################################### Run the simulation ##################################
sim_no_trt  <- MicroSim(v.M_1, n.i, n.t, v.n, d.c, d.e, Trt = FALSE, seed) 
sim_trt     <- MicroSim(v.M_1, n.i, n.t, v.n, d.c, d.e, Trt = TRUE, seed)

################################# Cost-effectiveness analysis #############################
# store the mean costs (and the MCSE) of each strategy in a new variable C (vector costs)
v.C  <- c(sim_no_trt$tc_hat, sim_trt$tc_hat) 
sd.C <- c(sd(sim_no_trt$tc), sd(sim_trt$tc)) / sqrt(n.i)
# store the mean QALYs (and the MCSE) of each strategy in a new variable E (vector effects)
v.E  <- c(sim_no_trt$te_hat, sim_trt$te_hat)
sd.E <- c(sd(sim_no_trt$te), sd(sim_trt$te)) / sqrt(n.i)

delta.C <- v.C[2] - v.C[1]                   # calculate incremental costs
delta.E <- v.E[2] - v.E[1]                   # calculate incremental QALYs
sd.delta.E <- sd(sim_trt$te - sim_no_trt$te) / sqrt(n.i) # MCSE of incremental costs
sd.delta.C <- sd(sim_trt$tc - sim_no_trt$tc) / sqrt(n.i) # MCSE of incremental QALYs

ICER <- delta.C / delta.E                    # calculate the ICER
results <- c(delta.C, delta.E, ICER)         # store the values in a new variable

# Create full incremental cost-effectiveness analysis table
table_micro <- data.frame(
  round(v.C, 0),               # costs per arm
  round(sd.C, 0),              # MCSE for costs
  round(v.E, 2),               # effectivenes per arm
  round(sd.E, 2),              # MCSE for effects
  c("", round(delta.C, 0)),    # incremental costs
  c("", round(sd.delta.C, 0)), # MCSE for incremental costs
  c("", round(delta.E, 2)),    # incremental QALYs 
  c("", round(sd.delta.E, 3)), # MCSE for QALYs gained
  c("", round(ICER, 0)),       # ICER
  row.names = v.Trt            # give row names
)

colnames(table_micro) = c("Costs", "",  "QALYs", "", "Incremental Costs", "", "QALYs Gained", "", "ICER") # give the columns names
table_micro                    # print the table 
