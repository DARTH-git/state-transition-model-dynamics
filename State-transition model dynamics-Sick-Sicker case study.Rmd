---
title: "State-transition model dynamic - Sick-Sicker case study"
author: 
  - Eline Krijkamp^[Equal contribution to this paper], MSc^[Department of Epidemiology, Erasmus MC, University Medical Center, Rotterdam, The Netherlands]
  - Fernando Alarid-Escudero$^1$, PhD^[Division of Health Policy and Management, University of Minnesota School of Public Health, Minneapolis, MN, USA]
  - Eva A. Enns, PhD$^3$
  - Myriam G.M. Hunink, PhD$^2$^[Center for Health Decision Sciences, Harvard T.H. Chan School of Public Health, Boston, USA]
  - Petros Pechlivanoglou, PhD^[The Hospital for Sick Children, Toronto and University of Toronto, Toronto, Ontario, Canada]
  - Hawre Jalal, MD, PhD^[University of Pittsburgh, Pittsburgh, PA, USA]
date: '`r Sys.Date()`'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, eval = TRUE, echo = FALSE}
###############################################################################
### A brief report -  ## 2019 ##
################################################################################
# This code forms the basis for the brief report: 
# 'State transition model dynamics TITLE' 
# Authors: 
# Please cite the article when using this code
################################################################################
# Demonstrate the array appraoch using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial we made use of 
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory 
```

## Sick-Sicker model
In the Sick-Sicker model, we simulate a hypothetical cohort of 25-year-old individuals over a lifetime (or reaching age 100-years old) using 75 annual cycles, represented with `n.t`. The cohort start in the "Healthy" health state (denoted H). Healthy individuals are at risk of developing the illness, at which point they would transition to the first stage of the disease (the "Sick" health state, denoted S1). Individuals that become sick incur a one-time utility decrement of 0.01 (`du.HS1`), disutility of transitioning from H to S1) and a one-time cost of \$1,000 (`ic.HS1`) that reflect the acute impacts of developing the illness. Sick individuals are at risk of further progressing to a more severe stage (the Sicker health state, denoted S2), which is constant in this case example. There is a chance that individuals in the Sick state eventually recover and return back to the Healthy state. However, once an individual reaches the Sicker health state, they cannot recover; that is, the probability of transitioning to the "Sick" or "Healthy" health states from the Sicker health state is zero. Individuals in the "Healthy" state face background mortality that is age-specific (i.e., time-dependent). Sick and Sicker individuals face an increased mortality in the form of a hazard rate ratio (HR) of 3 and 10 times, respectively, on the background mortality rate. Sick and Sicker individuals also experience increased health care costs and reduced QoL compared to healthy individuals. Once simulated individuals die, they transition to the Dead health state (denoted D), where they remain. When an individual dies, they incur a one-time cost of \$2,000 (`ic.D`) that reflects the acute care that might be received immediately preceding death. The state-transition diagram of the Sick-Sicker model is shown in Figure \ref{fig:STM Sick-Sicker}. The evolution of the cohort is simulated in one-year discrete-time cycles. Both costs and QALYs are discounted at an annual rate of 3%.


![Sick-Sicker \label{fig:STM Sick-Sicker}](figures/Sick-Sicker figure.png)



###01 Initial setup 
```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations 

#### 01.1.2 Load functions ####
source("functions/01_model-inputs_functions.R")
source("functions/02_simulation-model_functions.R")

#### 01.2 External parameters ####
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states 
d.c <- 0.03 # discount rate for costs 
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector

#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
  dplyr::select(Total) %>%
  as.matrix()              # vector with mortality rates

#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
```


### 02 Define and initialize matrices and vectors ####
#### Equation 1
```{r, message = FALSE, warning = FALSE}
#### 02.1 Transition probability matrix ####
# the m.P transition probability matrix at the first cycle
f.create_transition_prob_matrix(v.params = v.params.init, t = 1) 

#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
s0

#### 02.3 Cohort trace  
## Create the Markov trace matrix M capturing the proportion of the cohort 
# in each state at each cycle

m.M <- matrix(0,  # initialize cohort trace
              nrow = (n.t + 1), ncol = n.states, 
              dimnames = list(0:n.t, v.n))

m.M[1, ] <- s0   # store the initial state vector
```

### 03 Matrix Approach    
#### Equation 2   
```{r, message = FALSE, warning = FALSE}
for(t in 1:n.t){  # loop through the number of cycles
  # create the transition probability matrix for the current cycle
  m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) 
  # estimate the state vector for the next cycle (t + 1)
  m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 2   
}

head(round(m.M, 3)) # show the first six lines of the Markov trace
```

### 04 Array Approach     
```{r, message = FALSE, warning = FALSE}
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
             dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagnal of A
```

#### Equation 3 & 4  
```{r, message = FALSE, warning = FALSE}
a.A[, , 1]

# run the model 
for(t in 1:n.t){                     # loop through the number of cycles
  # create the transition probability matrix for the current cycle
  m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) 
#### Equation 4    #### 
  a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1 
}
```

#### Equation 5   
```{r, message = FALSE, warning = FALSE}
a.A[, , 2:3] # shown for two cycles
```

#### Equation 7 
```{r, message = FALSE, warning = FALSE}
# calculating M from A 
m.M_A <- t(colSums(a.A))   # sum over the colums of A and transpose 
```

```{r, eval = FALSE, echo = FALSE}
m.M == m.M_A # check if they are exactly the same
```


### 05 Apply state and transtion rewards 
```{r, message = FALSE, warning = FALSE}
#### 05.1 Create reward matrices for both costs and effects #### 
m.R_costs   <- f.create_transition_reward_matrix_costs(v.params = v.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(v.params = v.params.init)
```

#### Equation 8   
```{r, message = FALSE, warning = FALSE}
m.R_costs    # show the reward matrix for costs
m.R_effects  # show the reward matrix for effects
```

#### Equation 9 
```{r, message = FALSE, warning = FALSE}
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
a.O_costs <- a.O_effects <- array(0, dim = c(n.states, n.states, n.t + 1),
             dimnames = list(v.n, v.n, 0:n.t))

for(t in 1:n.t){ 
# element-wise-multiplication of array A with the rewards matrices
a.O_costs[, , t]   <- a.A[, , t] * m.R_costs   
a.O_effects[, , t] <- a.A[, , t] * m.R_effects 
}
```

```{r, eval = FALSE, echo = FALSE}
## Vector of expected costs per cycle
#v.cost_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.R_costs))))
## Vector of expected QALYs per cycle
#v.qaly_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.R_effect))))
```

#### Equation 10 
```{r, message = FALSE, warning = FALSE}
# calculate the expected costs per cycle
v.Costs <- rowSums(t(colSums(a.O_costs))) 
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O_effects))) 

TC <- t(v.Costs) %*% v.dwc  # calculate the total expected costs
TE <- t(v.QALYs) %*% v.dwe   # calculate the total expected QALYS

v.Results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.Results) <- c("Costs", "Effect") # name the vector
v.Results                    # print the results  
```


### 06 Plot cohort trace
```{r Sick-Sicker-Trace, echo = FALSE, fig.cap = '\\label{fig:Sick-Sicker-Trace}Cohort trace of the Sick-Sicker cohort model', message=FALSE, warning = FALSE, fig.pos = "H"} 
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme()
```

