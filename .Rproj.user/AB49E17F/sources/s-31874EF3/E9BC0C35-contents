---
title: "State-transition model dynamic - Sick-Sicker case study"
author: 
  - Eline Krijkamp^[Equal contribution to this paper], MSc^[Department of Epidemiology, Erasmus MC, University Medical Center, Rotterdam, The Netherlands]
  - Fernando Alarid-Escudero$^1$, PhD^[Division of Health Policy and Management, University of Minnesota School of Public Health, Minneapolis, MN, USA]
  - Eva A. Enns, PhD$^3$
  - Myriam G.M. Hunink, PhD$^2$^[Center for Health Decision Sciences, Harvard T.H. Chan School of Public Health, Boston, USA]
  - Petros Pechlivanoglou, PhD^[The Hospital for Sick Children, Toronto and University of Toronto, Toronto, Ontario, Canada]
  - Hawre Jalal, MD, PhD^[University of Pittsburgh, Pittsburgh, PA, USA]
date: '`r Sys.Date()`'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, eval = TRUE, echo = FALSE}
###############################################################################
### A brief report -  ## 2019 ##
################################################################################
# This code forms the basis for the brief report: 
# 'State transition model dynamics TITLE' 
# Authors: 
# Please cite the article when using this code
################################################################################
# Demonstrate the array appraoch using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial we made use of 
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory 
```

## Sick-Sicker model
In the Sick-Sicker model, we simulate a hypothetical cohort of 25-year-old individuals over a lifetime (or reaching age 100-years old) using 75 annual cycles, represented with `n.t`. The cohort start in the "Healthy" health state (denoted H). Healthy individuals are at risk of developing the illness, at which point they would transition to the first stage of the disease (the "Sick" health state, denoted S1). Individuals that become sick incur a one-time utility decrement of 0.01 (`du.HS1`), disutility of transitioning from H to S1) and a one-time cost of \$1,000 (`ic.HS1`) that reflect the acute impacts of developing the illness. Sick individuals are at risk of further progressing to a more severe stage (the Sicker health state, denoted S2), which is constant in this case example. There is a chance that individuals in the Sick state eventually recover and return back to the Healthy state. However, once an individual reaches the Sicker health state, they cannot recover; that is, the probability of transitioning to the "Sick" or "Healthy" health states from the Sicker health state is zero. Individuals in the "Healthy" state face background mortality that is age-specific (i.e., time-dependent). Sick and Sicker individuals face an increased mortality in the form of a hazard rate ratio (HR) of 3 and 10 times, respectively, on the background mortality rate. Sick and Sicker individuals also experience increased health care costs and reduced QoL compared to healthy individuals. Once simulated individuals die, they transition to the Dead health state (denoted D), where they remain. When an individual dies, they incur a one-time cost of \$2,000 (`ic.D`) that reflects the acute care that might be received immediately preceding death. The state-transition diagram of the Sick-Sicker model is shown in Figure \ref{fig:STM Sick-Sicker}. The evolution of the cohort is simulated in one-year discrete-time cycles. Both costs and QALYs are discounted at an annual rate of 3%.


![Sick-Sicker \label{fig:STM Sick-Sicker}](../figures/Sick-Sicker figure.png)








###01 Initial setup 
We start with loading the packages and functions needed. 
```{r, eval = TRUE, echo = FALSE, message = FALSE, warning = FALSE}
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations 

#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
```

#### 01.2 External parameters ####
In the external parameter set up we specify the staring age of the cohort, the number of cycles, the names of the health states and the discount rate used for costs and QALYs. The age specific mortality rate for those in the healthy state is based on the US overall mortality data from the Human Mortality Database. The base-case parameters are combined in a list using the `f.generate_init_params()` function. 

```{r, eval = TRUE, echo = TRUE, message = FALSE, warning = FALSE}
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states 
d.c <- 0.03 # discount rate for costs 
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector

#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("../data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
  dplyr::select(Total) %>%
  as.matrix()              # vector with mortality rates

#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
```


### 02 Define and initialize matrices and vectors ####
In this section we initialize the matrices and vectors used for storing the data. The transition probability matrix is initialized and filled for the current cycle using the function `f.create_transition_prob_matrix` with arguments `v.params` and `t`. The function starts with calculating the age-specific transition probabilities for the current cycle `t` and uses these parameters togehter with the parameters stored in `v.params.init` to fill the matrix. For the initiation of cycle 0 we use `t = 1`. The next step is to initialize the state vector `S0`. In the Sick-Sicker model all individuals start in the Healthy Health state. This state vector is used to inform the first row of initialized the Markov trace matrix `m.P`. 

#### Equation 1
```{r, message = FALSE, warning = FALSE}
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(v.params = v.params.init, t = 1) 

#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
s0

#### 02.3 Cohort trace  
## Create the Markov trace matrix m.M capturing the proportion of the cohort 
# in each state at each cycle

m.M <- matrix(0,  # initialize cohort trace
              nrow = (n.t + 1), ncol = n.states, 
              dimnames = list(0:n.t, v.n))

m.M[1, ] <- s0   # store the initial state vector
```
Now we specified all parameters for the general set up, we specified our input parameters, initialized all structures and fill the transition probabilty matrix `m.P` and the first row of our Cohort trace `m.M`. This allows us to start running the Markov model. 

### 03 Matrix approach  
In this section we show how we can run the Markov model for all cycles. The calculation shown in Equation 2 needs to be performed for all cycles. Therefore, we create a loop starting at `t = 1` until `t = n.t`. Since our transition probabilities are depending on the age of the individuals in the cohort (e.g. we use age dependent mortality rates), we need to update the transition probability matrix `m.P` every cycle. This cycle dependent matrix is used for the matrix multiplication, specified in `R` with `%*%`, with the cohort trace, `m.M[t, ]` to fill the next row of the `m.M[t + 1, ]`. 
#### Equation 2   
```{r, message = FALSE, warning = FALSE}
for(t in 1:n.t){  # loop through the number of cycles
  # create the transition probability matrix for the current cycle
  m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) 
  # estimate the state vector for the next cycle (t + 1)
  m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 2   
}
```

When printing the first six rows of `m.M` we see that everyone stars in the Healthy health state and over time the cohort transitions towards the other three health states. Until cycle 5, the proportion in `S1` is increasig after which it starts decreasing, while the proportion in `S2` and `D` is increasing towards the end of the model. We now ran our model using the Matrix approach and have information about state occupation at each cycle. This information allows us to apply state rewards (e.g. `c.Healthy`, `u.Healthy`. `u.S1` etc.), but it is not possible to include the transition rewards (e.g. `ic.HS1`, `du.HS1` and `ic.D`). In order to include these rewards we need to know when individuals made the transition. Therefore, in the next section we will explain the Array approach which makes it possible to include these rewards. 

```{r}
head(round(m.M, 3)) # show the first six lines of the Markov trace
```

### 04 Array approach  
The Array approach starts similar as the Matrix approach, meaning that secion 01 and 02 are identical for the two appraoched. The biggest difference between Matrix and array appraoch are the dimensions of the structure to store the dynamics of the cohort. While in the Matrix appoarch, we stored all information in matrix `m.M` of size `n.states` x  `n.states`, in this appraoch we add an dimension for time resulting in an array with dimensions `n.states` x  `n.states` x `n.t `. In `R` indexing start at 1, therefore, we initialize the array `a.A` using `n.state` + 1 to allow storing the results from cycle 0 until cycle `n.t`. The initial state vectors `s0` is used to inform the initial cycle of the array. 
```{r, message = FALSE, warning = FALSE}
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
             dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagnal of A
```

#### Equation 3 & 4  
We can now run the model using the Array appraoch. The function `f.create_transition_prob_matrix` is the same for both the Matrix and Array approach and needs to be calculated for each cycle. This `m.P` for the current cycle is multiplied with array `a.A` using element-wise multiplication `*`. The information about all transitions dynamics is stored in the next cycle in `a.A`.  

```{r, message = FALSE, warning = FALSE}
a.A[, , 1]

# run the model 
for(t in 1:n.t){                     # loop through the number of cycles
  # create the transition probability matrix for the current cycle
  m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) 
#### Equation 4    #### 
  a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1 
}
```

#### Equation 5  
To get an idea about how the information in `a.A` looks like we print it first three cycles. Like in the transition probability matrix `m.P`, the rows specify in which health state the individual started at the beginning of the cycle, while the columns inform you about where indidividual transitioned to. In cycle 0 everyone started in the healthy health states. At cycle 1 we can see that `r a.A["H","H", "1"]` of the cohort stayed healthy, `r a.A["H","S1", "1"]` transitioned from Healthy to Sick and ` r a.A["H","D", "1"]` died. Indeed, this looks very similar to the transition probabilities in this case example. From cycle 2 and onwards the information in `a.A` becomes more interesting. In cycle 2, we see that `r a.A["H","S1", "2"]` of the cohort stayed healthy, `r a.A["H","S1", "2"]` transitioned from Healthy towards Sick and `r a.A["H","D", "2"]` died while they started out healthy. In addition we see that `r a.A["S1","H", "2"]` of the cohort recoved from Healthy. `r a.A["S1","S1", "2"]` stayed Sick, `r a.A["S1","S2", "2"]` became Sicker out of Sick and `r a.A["S1","D", "2"]` died from Sick. All these values sum to 1 since we are still describing what happens to the cohort over time. 

```{r, message = FALSE, warning = FALSE}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3])
```

#### Equation 7 
When you sum the values in a column of `a.A`, e.g. Sick, you get which proportion of the cohort was in Sick at the end of that cycle. 
```{r}
sum(a.A[, "S1", 3])
```

By using the `colSums` function, summing over all columns of `a.A` we can do this for all points in time and when we transpose these results we get the traditional cohort trace `m.M`. Here names `m.M_A` to indicate it is generated via the Array approach.   
```{r, message = FALSE, warning = FALSE}
# calculating M from A 
m.M_A <- t(colSums(a.A))   # sum over the columns of a.A and transpose 
```

Since a Markov model is stocastic, these two approached should give identical resulst. We check this using the `==` function. We use rounding on 10 decimals, to avoid wrong `FALSE` restuls that have to do with floting point comparison issues. This means that functions allows you to test for equality with a specified difference tolerance.

```{r, eval = FALSE, echo = FALSE}
round(m.M, 10) == round(m.M_A, 10) # check if they are exactly the same
```

### 05 Apply state and transtion rewards 
```{r, message = FALSE, warning = FALSE}
#### 05.1 Create reward matrices for both costs and effects #### 
m.R_costs   <- f.create_transition_reward_matrix_costs(v.params = v.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(v.params = v.params.init)
```

#### Equation 8   
```{r, message = FALSE, warning = FALSE}
m.R_costs    # show the reward matrix for costs
m.R_effects  # show the reward matrix for effects
```

#### Equation 9 
```{r, message = FALSE, warning = FALSE}
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
a.O_costs <- a.O_effects <- array(0, dim = c(n.states, n.states, n.t + 1),
             dimnames = list(v.n, v.n, 0:n.t))

for(t in 1:n.t){ 
# element-wise-multiplication of array A with the rewards matrices
a.O_costs[, , t]   <- a.A[, , t] * m.R_costs   
a.O_effects[, , t] <- a.A[, , t] * m.R_effects 
}
```

```{r, eval = FALSE, echo = FALSE}
## Vector of expected costs per cycle
#v.cost_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.R_costs))))
## Vector of expected QALYs per cycle
#v.qaly_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.R_effect))))
```

#### Equation 10 
The final step is to calculated to the total expected discounted costs and QALYs. We start by calculating the expected cost and QALYs per cycle. These values, stored in the vectors `v.Costs` and `v.QALYs`, in turn are multiplied with the vector of discount weights, `v.dwc`1 and `v.dwe`, respectively. This gives us the total expected discounted cost (`TC`) and QALYs (`TE`. 
```{r, message = FALSE, warning = FALSE}
# calculate the expected costs per cycle
v.Costs <- rowSums(t(colSums(a.O_costs))) 
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O_effects))) 

TC <- t(v.Costs) %*% v.dwc   # calculate the total expected discounted costs
TE <- t(v.QALYs) %*% v.dwe   # calculate the total expected discounted QALYS

v.Results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.Results) <- c("Costs", "Effect") # name the vector
v.Results                    # print the results  
```


### 06 Plot cohort trace
The results of a cohort trace are much easier to interpret via a graph. Using the function `ggplot` can show the proportion of the cohort in each state (y-axis) at each cycle (x-axis).
```{r Sick-Sicker-Trace, echo = FALSE, fig.cap = '\\label{fig:Sick-Sicker-Trace}Cohort trace of the Sick-Sicker cohort model', message=FALSE, warning = FALSE, fig.pos = "H"} 
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
  theme()
```

