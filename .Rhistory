sum(a.A[, , 3]) # sum for t = 3
sum(a.A[, "S", 3]) # sum the column of S at t = 3
# calculating M from A
m.MViaA <- t(colSums(a.A))   # sum over the columns of a.A and transpose
round(m.M, 10) == round(m.MViaA, 10) # check if they are exactly the same
#### 05.1 Create reward matrices for both costs and effects ####
m.R.costs <- m.R.effects <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix for costs
# From Healthy
m.R.costs["H", "H"]  <- c.H
m.R.costs["H", "S"]  <- c.H
m.R.costs["H", "D"]  <- c.H + ic.D
# From Sick
m.R.costs["S", "H"]  <- c.S
m.R.costs["S", "S"]  <- c.S
m.R.costs["S", "D"]  <- c.S + ic.D
# From Death
m.R.costs["D", "H"]  <- c.D
m.R.costs["D", "S"]  <- c.D
m.R.costs["D", "D"]  <- c.D
# Fill in matrix for effects
# From Healthy
m.R.effects["H", "H"]  <- u.H
m.R.effects["H", "S"]  <- u.H - du.HS
m.R.effects["H", "D"]  <- u.H
# From Sick
m.R.effects["S", "H"]  <- u.S
m.R.effects["S", "S"]  <- u.S
m.R.effects["S", "D"]  <- u.S + ic.D
# From Death
m.R.effects["D", "H"]  <- u.D
m.R.effects["D", "S"]  <- u.D
m.R.effects["D", "D"]  <- u.D
m.R.costs    # show the reward matrix for costs
m.R.effects  # show the reward matrix for effects
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
a.O.costs <- a.O.effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
for(t in 1:n.t){
# element-wise-multiplication of array A with the rewards matrices
a.O.costs[, , t]   <- a.A[, , t] * m.R.costs
a.O.effects[, , t] <- a.A[, , t] * m.R.effects
}
# calculate the expected costs per cycle
v.costs <- rowSums(t(colSums(a.O.costs)))
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O.effects)))
TC <- sum(v.costs)  # calculate the total expected costs
TE <- sum(v.QALYs)  # calculate the total expected QALYS
v.results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.results) <- c("Costs", "Effect") # name the vector
v.results                    # print the results
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
#### 01.2.3 Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.17   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.35   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
v.m0 <- c(H = 1, S = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
}
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- v.m0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
#### 01.2.3 Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.21   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.35   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
v.m0 <- c(H = 1, S = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
}
head(round(m.M, 3)) # show the first six lines of the Markov cohort trace
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- v.m0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.2.1 General setup ####
age         <- 70  # age of starting cohort
n.t         <- 30  # time horizon, number of cycles
v.age.names <- age:(age + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
#### 01.2.3 Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.25   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.31   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
v.m0 <- c(H = 1, S = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
}
head(round(m.M, 3)) # show the first six lines of the Markov cohort trace
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- v.m0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
#### 01.2.3 Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.25   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.15   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
v.m0 <- c(H = 1, S = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
}
head(round(m.M, 3)) # show the first six lines of the Markov cohort trace
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- v.m0 # store the initial state vector in the diagonal of A
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
#### 01.2.3 Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.30   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.15   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
v.m0 <- c(H = 1, S = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
###############################################################################
### A brief report   ## 2019 ##
################################################################################
# This code forms the basis for the brief report:
# 'An alternative representation of state-transition model dynamics'
# Please cite the article when using this code
################################################################################
# Demonstrate the array approach using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial, we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.2.1 General setup ####
age         <- 70  # age of starting cohort
n.t         <- 30  # time horizon, number of cycles
v.age.names <- age:(age + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
#### 01.2.3 Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.30   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.15   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
v.m0 <- c(H = 1, S = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
}
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
ggtitle("Cohort trace of the generic 3-state model")+
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
ggtitle("Cohort trace of the simple 3-state model")+
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
knitr::opts_chunk$set(echo = TRUE)
detach("package:datasets", unload=TRUE)
