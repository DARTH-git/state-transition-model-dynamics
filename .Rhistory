delta.E <- v.E[2] - v.E[1]                   # calculate incremental QALYs
se.delta.E <- sd(sim_trt$te - sim_no_trt$te) / sqrt(n.i) # Monte Carlo squared error (MCSE) of incremental costs
se.delta.C <- sd(sim_trt$tc - sim_no_trt$tc) / sqrt(n.i) # Monte Carlo squared error (MCSE) of incremental QALYs
ICER    <- delta.C / delta.E                 # calculate the ICER
results <- c(delta.C, delta.E, ICER)         # store the values in a new variable
# Create full incremental cost-effectiveness analysis table
table_micro <- data.frame(
c(round(v.C, 0),  ""),           # costs per arm
c(round(se.C, 0), ""),           # MCSE for costs
c(round(v.E, 3),  ""),           # health outcomes per arm
c(round(se.E, 3), ""),           # MCSE for health outcomes
c("", round(delta.C, 0),   ""),  # incremental costs
c("", round(se.delta.C, 0),""),  # MCSE for incremental costs
c("", round(delta.E, 3),   ""),  # incremental QALYs
c("", round(se.delta.E, 3),""),  # MCSE for health outcomes (QALYs) gained
c("", round(ICER, 0),      "")   # ICER
)
rownames(table_micro) <- c(v.Trt, "* are MCSE values")  # name the rows
colnames(table_micro) <- c("Costs", "*",  "QALYs", "*", "Incremental Costs", "*", "QALYs Gained", "*", "ICER") # name the columns
table_micro  # print the table
sim_no_trt$TS
sim_no_trt$TS
dim(sim_no_trt$TS)
count(sim_no_trt$TS[,1]=="H->H")
sim_no_trt$TS[,1]=="H->H"
a.A_MicroSim["H", "H", 1] <- sum(sim_no_trt$TS[, 1]=="H->H")
a.A_MicroSim["H", "H", 1] <- (sim_no_trt$TS[1:4, 1]=="H->H")
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
(sim_no_trt$TS[1:4, 1]=="H->H")
count(sim_no_trt$TS[1:4, 1]=="H->H")
(sim_no_trt$TS[1:4, 1]=="H->H")
sum((sim_no_trt$TS[1:4, 1]=="H->H"), na.rm = TRUE)
sum((sim_no_trt$TS[, 1]=="H->H"), na.rm = TRUE)
n.i
sum((sim_no_trt$TS[, 1]=="H->H"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "H", 1] <- sum((sim_no_trt$TS[, 1]=="H->H"), na.rm = TRUE)/n.i
.A_MicroSim <
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
a.A_MicroSim["H", "H", 1] <- sum((sim_no_trt$TS[, 1]=="H->H"), na.rm = TRUE)/n.i
array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
n.states
n.states
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(v.params = v.params.init, t = 1)
head(sim_no_trt$TS) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
a.A_MicroSim <- array(0, dim = c(n.States, n.States, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
n.States
n.states
###############################################################################
### A brief report -  ## 2019 ##
################################################################################
# This code forms the basis for the brief report:
# 'State transition model dynamics TITLE'
# Authors:
# Please cite the article when using this code
################################################################################
# Demonstrate the arrayapproachusing the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("../data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(v.params = v.params.init, t = 1)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
s0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t)
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 2
}
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t)
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
sum(a.A[, "S1", 3]) # sum the column of S1 at t = 3
# calculating M from A
m.M_A <- t(colSums(a.A))   # sum over the columns of a.A and transpose
round(m.M, 10) == round(m.M_A, 10) # check if they are exactly the same
#### 05.1 Create reward matrices for both costs and effects ####
m.R_costs   <- f.create_transition_reward_matrix_costs(v.params = v.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(v.params = v.params.init)
m.R_costs    # show the reward matrix for costs
m.R_effects  # show the reward matrix for effects
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
a.O_costs <- a.O_effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
for(t in 1:n.t){
# element-wise-multiplication of array A with the rewards matrices
a.O_costs[, , t]   <- a.A[, , t] * m.R_costs
a.O_effects[, , t] <- a.A[, , t] * m.R_effects
}
a.A_MicroSim
head(sim_no_trt$TS) # the transition array
source("../R/Appendix D_online_supp.R") # load and run the Microsimulation of the Sick-Sicker model
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("../data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
source("../R/Appendix D_online_supp.R") # load and run the Microsimulation of the Sick-Sicker model
head(sim_no_trt$TS) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
a.A_MicroSim
a.A_MicroSim["H", "H", 1] <- sum((sim_no_trt$TS[, 1]=="H->H"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "H", 1]
a.A_MicroSim["H", "H", ] <- sum((sim_no_trt$TS[, ]=="H->H"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "H", ] <- sum((sim_no_trt$TS[, ]=="H->H"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "S1", ] <- sum((sim_no_trt$TS[, ]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "S2", ] <- sum((sim_no_trt$TS[, ]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "D", ] <- sum((sim_no_trt$TS[, ]=="H->D"), na.rm = TRUE)/n.i
a.A_MicroSim[,,1]
n.i
for (t in 1:n.t){
for (s in 1:v.s){
a.A_MicroSim[s, "H",  t] <- sum((sim_no_trt$TS[,t ]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim[s, "S1", t] <- sum((sim_no_trt$TS[,t ]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim[s, "S2", t] <- sum((sim_no_trt$TS[, t]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim[s, "D",  t] <- sum((sim_no_trt$TS[, t]=="H->D") , na.rm = TRUE)/n.i
}
}
v.s
v.s
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("../data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
for (t in 1:n.t){
for (s in 1:v.n){
a.A_MicroSim[s, "H",  t] <- sum((sim_no_trt$TS[,t ]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim[s, "S1", t] <- sum((sim_no_trt$TS[,t ]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim[s, "S2", t] <- sum((sim_no_trt$TS[, t]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim[s, "D",  t] <- sum((sim_no_trt$TS[, t]=="H->D") , na.rm = TRUE)/n.i
}
}
v.n
v.n[1]
for (t in 1:n.t){
for (s in 1:v.n){
a.A_MicroSim[v.n[s], "H",  t] <- sum((sim_no_trt$TS[,t ]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "S1", t] <- sum((sim_no_trt$TS[,t ]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "S2", t] <- sum((sim_no_trt$TS[, t]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "D",  t] <- sum((sim_no_trt$TS[, t]=="H->D") , na.rm = TRUE)/n.i
}
}
s=1
t=1
a.A_MicroSim[v.n[s], "H",  t] <- sum((sim_no_trt$TS[,t ]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "S1", t] <- sum((sim_no_trt$TS[,t ]=="H->S1"), na.rm = TRUE)/n.i
for (t in 1:n.t){
for (s in 1:v.n){
a.A_MicroSim[v.n[s], "H",  t] <- sum((sim_no_trt$TS[,t ]=="v.n[s]->H") , na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "S1", t] <- sum((sim_no_trt$TS[,t ]=="v.n[s]->S1"), na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "S2", t] <- sum((sim_no_trt$TS[, t]=="v.n[s]->S2"), na.rm = TRUE)/n.i
a.A_MicroSim[v.n[s], "D",  t] <- sum((sim_no_trt$TS[, t]=="v.n[s]->D") , na.rm = TRUE)/n.i
}
}
for (t in 1:n.t){
a.A_MicroSim["H", "H",  t] <- sum((sim_no_trt$TS[,t ]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim["H", "S1", t] <- sum((sim_no_trt$TS[,t ]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "S2", t] <- sum((sim_no_trt$TS[, t]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "D",  t] <- sum((sim_no_trt$TS[, t]=="H->D") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[,t ]=="S1->H") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "S1", t] <- sum((sim_no_trt$TS[,t ]=="S1->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["S1", "S2", t] <- sum((sim_no_trt$TS[, t]=="S1->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["S1", "D",  t] <- sum((sim_no_trt$TS[, t]=="S1->D") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[,t ]=="S2->H") , na.rm = TRUE)/n.i
a.A_MicroSim["S2", "S1", t] <- sum((sim_no_trt$TS[,t ]=="S2->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["S2", "S2", t] <- sum((sim_no_trt$TS[, t]=="S2->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["S2", "D",  t] <- sum((sim_no_trt$TS[, t]=="S2->D") , na.rm = TRUE)/n.i
a.A_MicroSim["D", "H",  t] <- sum((sim_no_trt$TS[,t ]=="D->H") , na.rm = TRUE)/n.i
a.A_MicroSim["D", "S1", t] <- sum((sim_no_trt$TS[,t ]=="D->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["D", "S2", t] <- sum((sim_no_trt$TS[, t]=="D->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["D", "D",  t] <- sum((sim_no_trt$TS[, t]=="D->D") , na.rm = TRUE)/n.i
}
n.t
for (t in 2:n.t){
a.A_MicroSim["H", "H",  t] <- sum((sim_no_trt$TS[, t]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim["H", "S1", t] <- sum((sim_no_trt$TS[, t]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "S2", t] <- sum((sim_no_trt$TS[, t]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "D",  t] <- sum((sim_no_trt$TS[, t]=="H->D") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t]=="S1->H") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "S1", t] <- sum((sim_no_trt$TS[, t]=="S1->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["S1", "S2", t] <- sum((sim_no_trt$TS[, t]=="S1->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["S1", "D",  t] <- sum((sim_no_trt$TS[, t]=="S1->D") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t]=="S2->H") , na.rm = TRUE)/n.i
a.A_MicroSim["S2", "S1", t] <- sum((sim_no_trt$TS[, t]=="S2->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["S2", "S2", t] <- sum((sim_no_trt$TS[, t]=="S2->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["S2", "D",  t] <- sum((sim_no_trt$TS[, t]=="S2->D") , na.rm = TRUE)/n.i
a.A_MicroSim["D", "H",  t] <- sum((sim_no_trt$TS[, t]=="D->H") , na.rm = TRUE)/n.i
a.A_MicroSim["D", "S1", t] <- sum((sim_no_trt$TS[, t]=="D->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["D", "S2", t] <- sum((sim_no_trt$TS[, t]=="D->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["D", "D",  t] <- sum((sim_no_trt$TS[, t]=="D->D") , na.rm = TRUE)/n.i
}
n.t
source("../R/Appendix D_online_supp.R") # load and run the Microsimulation of the Sick-Sicker model
head(sim_no_trt$TS) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 #
s0
a.A_MicroSim
s0
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("../data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(v.params = v.params.init, t = 1)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
s0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0   # store the initial state vector
head(sim_no_trt$TS) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 #
diag(a.A_MicroSim[, , 1]) <- s0 #
for (t in 2:n.t+1){
a.A_MicroSim["H", "H",  t] <- sum((sim_no_trt$TS[, t]=="H->H") , na.rm = TRUE)/n.i
a.A_MicroSim["H", "S1", t] <- sum((sim_no_trt$TS[, t]=="H->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "S2", t] <- sum((sim_no_trt$TS[, t]=="H->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["H", "D",  t] <- sum((sim_no_trt$TS[, t]=="H->D") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t]=="S1->H") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "S1", t] <- sum((sim_no_trt$TS[, t]=="S1->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["S1", "S2", t] <- sum((sim_no_trt$TS[, t]=="S1->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["S1", "D",  t] <- sum((sim_no_trt$TS[, t]=="S1->D") , na.rm = TRUE)/n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t]=="S2->H") , na.rm = TRUE)/n.i
a.A_MicroSim["S2", "S1", t] <- sum((sim_no_trt$TS[, t]=="S2->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["S2", "S2", t] <- sum((sim_no_trt$TS[, t]=="S2->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["S2", "D",  t] <- sum((sim_no_trt$TS[, t]=="S2->D") , na.rm = TRUE)/n.i
a.A_MicroSim["D", "H",  t] <- sum((sim_no_trt$TS[, t]=="D->H") , na.rm = TRUE)/n.i
a.A_MicroSim["D", "S1", t] <- sum((sim_no_trt$TS[, t]=="D->S1"), na.rm = TRUE)/n.i
a.A_MicroSim["D", "S2", t] <- sum((sim_no_trt$TS[, t]=="D->S2"), na.rm = TRUE)/n.i
a.A_MicroSim["D", "D",  t] <- sum((sim_no_trt$TS[, t]=="D->D") , na.rm = TRUE)/n.i
}
a.A_MicroSim
a.A_MicroSim==a.A
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t)
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A_MicroSim==a.A
head(sim_no_trt$TS[1:3, 1:4]) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A_MicroSim[, , 1]) <- s0 #
for (t in 2:n.t + 1){
a.A_MicroSim["H", "H",  t] <- sum((sim_no_trt$TS[, t] == "H->H") , na.rm = TRUE) / n.i
a.A_MicroSim["H", "S1", t] <- sum((sim_no_trt$TS[, t] == "H->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["H", "S2", t] <- sum((sim_no_trt$TS[, t] == "H->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["H", "D",  t] <- sum((sim_no_trt$TS[, t] == "H->D") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t] == "S1->H") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "S1", t] <- sum((sim_no_trt$TS[, t] == "S1->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["S1", "S2", t] <- sum((sim_no_trt$TS[, t] == "S1->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["S1", "D",  t] <- sum((sim_no_trt$TS[, t] == "S1->D") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t] == "S2->H") , na.rm = TRUE) / n.i
a.A_MicroSim["S2", "S1", t] <- sum((sim_no_trt$TS[, t] == "S2->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["S2", "S2", t] <- sum((sim_no_trt$TS[, t] == "S2->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["S2", "D",  t] <- sum((sim_no_trt$TS[, t] == "S2->D") , na.rm = TRUE) / n.i
a.A_MicroSim["D", "H",  t] <- sum((sim_no_trt$TS[, t] == "D->H") , na.rm = TRUE) / n.i
a.A_MicroSim["D", "S1", t] <- sum((sim_no_trt$TS[, t] == "D->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["D", "S2", t] <- sum((sim_no_trt$TS[, t] == "D->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["D", "D",  t] <- sum((sim_no_trt$TS[, t] == "D->D") , na.rm = TRUE) / n.i
}
head(sim_no_trt$TS[1:3, 10:14]) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A_MicroSim[, , 1]) <- s0 #
for (t in 2:n.t + 1){
a.A_MicroSim["H", "H",  t] <- sum((sim_no_trt$TS[, t] == "H->H") , na.rm = TRUE) / n.i
a.A_MicroSim["H", "S1", t] <- sum((sim_no_trt$TS[, t] == "H->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["H", "S2", t] <- sum((sim_no_trt$TS[, t] == "H->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["H", "D",  t] <- sum((sim_no_trt$TS[, t] == "H->D") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t] == "S1->H") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "S1", t] <- sum((sim_no_trt$TS[, t] == "S1->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["S1", "S2", t] <- sum((sim_no_trt$TS[, t] == "S1->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["S1", "D",  t] <- sum((sim_no_trt$TS[, t] == "S1->D") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t] == "S2->H") , na.rm = TRUE) / n.i
a.A_MicroSim["S2", "S1", t] <- sum((sim_no_trt$TS[, t] == "S2->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["S2", "S2", t] <- sum((sim_no_trt$TS[, t] == "S2->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["S2", "D",  t] <- sum((sim_no_trt$TS[, t] == "S2->D") , na.rm = TRUE) / n.i
a.A_MicroSim["D", "H",  t] <- sum((sim_no_trt$TS[, t] == "D->H") , na.rm = TRUE) / n.i
a.A_MicroSim["D", "S1", t] <- sum((sim_no_trt$TS[, t] == "D->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["D", "S2", t] <- sum((sim_no_trt$TS[, t] == "D->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["D", "D",  t] <- sum((sim_no_trt$TS[, t] == "D->D") , na.rm = TRUE) / n.i
}
head(sim_no_trt$TS[1:4, 10:14]) # the transition array
head(sim_no_trt$TR) # the cohort trace from the microsimulation
a.A_MicroSim <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A_MicroSim[, , 1]) <- s0 #
for (t in 2:n.t + 1){
a.A_MicroSim["H", "H",  t] <- sum((sim_no_trt$TS[, t] == "H->H") , na.rm = TRUE) / n.i
a.A_MicroSim["H", "S1", t] <- sum((sim_no_trt$TS[, t] == "H->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["H", "S2", t] <- sum((sim_no_trt$TS[, t] == "H->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["H", "D",  t] <- sum((sim_no_trt$TS[, t] == "H->D") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t] == "S1->H") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "S1", t] <- sum((sim_no_trt$TS[, t] == "S1->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["S1", "S2", t] <- sum((sim_no_trt$TS[, t] == "S1->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["S1", "D",  t] <- sum((sim_no_trt$TS[, t] == "S1->D") , na.rm = TRUE) / n.i
a.A_MicroSim["S1", "H",  t] <- sum((sim_no_trt$TS[, t] == "S2->H") , na.rm = TRUE) / n.i
a.A_MicroSim["S2", "S1", t] <- sum((sim_no_trt$TS[, t] == "S2->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["S2", "S2", t] <- sum((sim_no_trt$TS[, t] == "S2->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["S2", "D",  t] <- sum((sim_no_trt$TS[, t] == "S2->D") , na.rm = TRUE) / n.i
a.A_MicroSim["D", "H",  t] <- sum((sim_no_trt$TS[, t] == "D->H") , na.rm = TRUE) / n.i
a.A_MicroSim["D", "S1", t] <- sum((sim_no_trt$TS[, t] == "D->S1"), na.rm = TRUE) / n.i
a.A_MicroSim["D", "S2", t] <- sum((sim_no_trt$TS[, t] == "D->S2"), na.rm = TRUE) / n.i
a.A_MicroSim["D", "D",  t] <- sum((sim_no_trt$TS[, t] == "D->D") , na.rm = TRUE) / n.i
}
source("../R/Appendix D_online_supp.R") # load and run the Microsimulation of the Sick-Sicker model
citation()
setwd("~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH/state-transition-model-dynamics")
knitr::opts_chunk$set(echo = TRUE)
#doc.type <- knitr::opts_knit$get('rmarkdown.pandoc.to')
#opts_chunk$set(echo = FALSE, cache=FALSE)
# For some reason I can't manage reading these files so I copied it to the markdown for now but we need to see how we can source the files.
setwd("~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH/state-transition-model-dynamics")
source("../R/01_model-inputs.R")
source("R/01_model-inputs.R")
# For some reason I can't manage reading these files so I copied it to the markdown for now but we need to see how we can source the files.
setwd("~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH framework/Decision-Modeling-Framework")
source("R/01_model-inputs.R")
getwd()
# For some reason I can't manage reading these files so I copied it to the markdown for now but we need to see how we can source the files.
setwd("~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH framework/Decision-Modeling-Framework")
knitr::root.dir("~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH framework/Decision-Modeling-Framework")
knitr::opts_knit$set(root.dir = '~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH framework/Decision-Modeling-Framework' )
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '~/Dropbox (Persoonlijk)/03_Onderzoek/DARTH framework/Decision-Modeling-Framework')
#doc.type <- knitr::opts_knit$get('rmarkdown.pandoc.to')
#opts_chunk$set(echo = FALSE, cache=FALSE)
# For some reason I can't manage reading these files so I copied it to the markdown for now but we need to see how we can source the files.
source("R/01_model-inputs.R")
getwd
getwd()
x <- getwd()
x
