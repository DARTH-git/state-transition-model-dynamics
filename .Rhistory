# From Healthy
m.R["H", "H"]   <- u.H
m.R["H", "S"]   <- u.H - du.HS
m.R["H", "D"]   <- u.H
# From Sick
m.R["S", "H"]   <- u.S
m.R["S", "S"]   <- u.S
m.R["S", "D"]   <- u.S
# From Death
m.R["D", "H"]   <- u.D
m.R["D", "S"]   <- u.D
m.R["D", "D"]   <- u.D
return(m.R)
}
)
}
#------------------------------------------------------#
#### Generate base-case parameters set              ####
#------------------------------------------------------#
f.generate_init_params <- function(){ # User defined
df.params.init <- data.frame(
# Costs
c.H   = 1000,   # cost of remaining one cycle healthy
c.S   = 3000,   # cost of remaining one cycle sick
c.D   = 0,      # cost of being dead (per cycle)
# State utilities
u.H   = 1,      # utility when healthy
u.S   = 0.60,   # utility when sick
u.D   = 0,      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.17,   # probability to become sick when healthy
p.HD  = 0.05,    # probability to die when healthy
p.SH  = 0.35,    # probability to become healthy when sick
p.SD  = 0.10,    # probability to die when healthy
# Transition rewards
du.HS  = 0.04,  # one-time utility decrement when becoming sick
ic.HS  = 500,   # one-time cost of becoming sick
ic.D   = 4000   # one-time cost of dying
)
return(df.params.init)
}
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(df.params = df.params.init, t = 1)
#------------------------------------------------------#
#### Generate base-case parameters set              ####
#------------------------------------------------------#
f.generate_init_params <- function(){ # User defined
df.params.init <- data.frame(
# Costs
c.H   = 1000,   # cost of remaining one cycle healthy
c.S   = 3000,   # cost of remaining one cycle sick
c.D   = 0,      # cost of being dead (per cycle)
# State utilities
u.H   = 1,      # utility when healthy
u.S   = 0.60,   # utility when sick
u.D   = 0,      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.17,   # probability to become sick when healthy
p.HD  = 0.05,    # probability to die when healthy
p.SH  = 0.35,    # probability to become healthy when sick
p.SD  = 0.10,    # probability to die when healthy
# Transition rewards
du.HS  = 0.04,  # one-time utility decrement when becoming sick
ic.HS  = 500,   # one-time cost of becoming sick
ic.D   = 4000   # one-time cost of dying
)
return(df.params.init)
}
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(df.params = df.params.init, t = 1)
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/generic example/01_model-inputs_functions.R")
source("../functions/generic example/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 60  # age of starting cohort
n.t         <- 60  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
df.params.init
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(df.params = df.params.init, t = 1)
f.create_transition_prob_matrix
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/generic example/01_model-inputs_functions.R")
source("../functions/generic example/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 60  # age of starting cohort
n.t         <- 60  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(df.params = df.params.init, t = 1)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S = 0, D = 0)
s0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(df.params = df.params.init, t = t)
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 2
}
head(round(m.M, 3)) # show the first six lines of the Markov cohort trace
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t)
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(df.params = df.params.init, t = t)
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
sum(a.A[, "S", 3]) # sum the column of S at t = 3
# calculating M from A
m.M_A <- t(colSums(a.A))   # sum over the columns of a.A and transpose
round(m.M, 10) == round(m.M_A, 10) # check if they are exactly the same
#### 05.1 Create reward matrices for both costs and effects ####
m.R_costs   <- f.create_transition_reward_matrix_costs(v.params = v.params.init)
#### 05.1 Create reward matrices for both costs and effects ####
m.R_costs   <- f.create_transition_reward_matrix_costs(df.params = df.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(df.params = df.params.init)
m.R_costs    # show the reward matrix for costs
m.R_effects  # show the reward matrix for effects
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
a.O_costs <- a.O_effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
for(t in 1:n.t){
# element-wise-multiplication of array A with the rewards matrices
a.O_costs[, , t]   <- a.A[, , t] * m.R_costs
a.O_effects[, , t] <- a.A[, , t] * m.R_effects
}
# calculate the expected costs per cycle
v.Costs <- rowSums(t(colSums(a.O_costs)))
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O_effects)))
TC <- t(v.Costs) %*% v.dwc   # calculate the total expected discounted costs
TE <- t(v.QALYs) %*% v.dwe   # calculate the total expected discounted QALYS
v.Results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.Results) <- c("Costs", "Effect") # name the vector
v.Results                    # print the results
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
theme()
#### 01.2.1 General setup ####
n.age.init  <- 60  # age of starting cohort
n.t         <- 60  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("Healthy", "Sick", "Dead") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(df.params = df.params.init)
#### 01.2.1 General setup ####
n.age.init  <- 60  # age of starting cohort
n.t         <- 60  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(df.params = df.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- f.create_transition_prob_matrix(df.params = df.params.init)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S = 0, D = 0)
s0
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0   # store the initial state vector
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
theme()
m.M
knitr::opts_chunk$set(echo = TRUE)
###############################################################################
### A brief report   ## 2019 ##
################################################################################
# This code forms the basis for the brief report:
# 'An alternative representation of state-transition model dynamics'
# Please cite the article when using this code
################################################################################
# Demonstrate the array approach using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/generic example/01_model-inputs_functions.R")
source("../functions/generic example/02_simulation-model_functions.R")
#### 01.2.1 General setup ####
n.age.init  <- 60  # age of starting cohort
n.t         <- 60  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
#### 01.2.1 General setup ####
n.age.init  <- 70  # age of starting cohort
n.t         <- 50  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- f.create_transition_prob_matrix(df.params = df.params.init)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S = 0, D = 0)
s0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 2
}
head(round(m.M, 3)) # show the first six lines of the Markov cohort trace
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
sum(a.A[, "S", 3]) # sum the column of S at t = 3
# calculating M from A
m.M_A <- t(colSums(a.A))   # sum over the columns of a.A and transpose
round(m.M, 10) == round(m.M_A, 10) # check if they are exactly the same
#### 05.1 Create reward matrices for both costs and effects ####
m.R_costs   <- f.create_transition_reward_matrix_costs(df.params = df.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(df.params = df.params.init)
m.R_costs    # show the reward matrix for costs
m.R_effects  # show the reward matrix for effects
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
a.O_costs <- a.O_effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
for(t in 1:n.t){
# element-wise-multiplication of array A with the rewards matrices
a.O_costs[, , t]   <- a.A[, , t] * m.R_costs
a.O_effects[, , t] <- a.A[, , t] * m.R_effects
}
## Vector of expected costs per cycle
#v.cost_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.R_costs))))
## Vector of expected QALYs per cycle
#v.qaly_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.R_effect))))
# calculate the expected costs per cycle
v.Costs <- rowSums(t(colSums(a.O_costs)))
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O_effects)))
TC <- t(v.Costs) %*% v.dwc   # calculate the total expected discounted costs
TE <- t(v.QALYs) %*% v.dwe   # calculate the total expected discounted QALYS
v.Results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.Results) <- c("Costs", "Effect") # name the vector
v.Results                    # print the results
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
theme()
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
theme()
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
theme()
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10))+
theme()
knitr::opts_chunk$set(echo = TRUE)
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
knitr::opts_chunk$set(echo = TRUE)
m.R_costs    # show the reward matrix for costs
###############################################################################
### A brief report   ## 2019 ##
################################################################################
# This code forms the basis for the brief report:
# 'An alternative representation of state-transition model dynamics'
# Please cite the article when using this code
################################################################################
# Demonstrate the array approach using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
source("../functions/02_simulation-model_functions.R")
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- f.create_transition_prob_matrix(df.params = df.params.init)
#### 01.2.1 General setup ####
n.age.init  <- 70  # age of starting cohort
n.t         <- 50  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
v.s.init <- c(H = 1, S = 0, D = 0) # initial state vector
#### 01.2.3 Generate initial set of base-case external parameters ####
df.params.init <- f.generate_init_params()
## Create name of parameters
df.names.params <- names(df.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- f.create_transition_prob_matrix(df.params = df.params.init)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy health state
s0 <- c(H = 1, S = 0, D = 0)
s0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
}
head(round(m.M, 3)) # show the first six lines of the Markov cohort trace
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagonal of A
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
a.A[, , 1:3] # shown for two cycles
sum(a.A[, , 3]) # sum for t = 3
sum(a.A[, "S", 3]) # sum the column of S at t = 3
# calculating M from A
m.M_A <- t(colSums(a.A))   # sum over the columns of a.A and transpose
round(m.M, 10) == round(m.M_A, 10) # check if they are exactly the same
#### 05.1 Create reward matrices for both costs and effects ####
m.R_costs   <- f.create_transition_reward_matrix_costs(df.params = df.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(df.params = df.params.init)
m.R_costs    # show the reward matrix for costs
m.R_effects  # show the reward matrix for effects
