---
title: 'State-transition cohort models in R: From conceptualization to implementation'
author: 
  - Fernando Alarid-Escudero, PhD^[Division of Health Policy and Management, University of Minnesota School of Public Health, Minneapolis, MN, USA]
  - Eline Krijkamp, MSc^[Department of Epidemiology, Erasmus MC, University Medical Center, Rotterdam, The Netherlands]
  - Eva A. Enns, PhD$^1$
  - Myriam G.M. Hunink, PhD$^2$^[Center for Health Decision Sciences, Harvard T.H. Chan School of Public Health, Boston, USA]
  - Petros Pechlivanoglou, PhD^[The Hospital for Sick Children, Toronto and University of Toronto, Toronto, Ontario, Canada]
  - Hawre Jalal, MD, PhD^[University of Pittsburgh, Pittsburgh, PA, USA]
date: '`r Sys.Date()`'
documentclass: "article"
output:
  bookdown::pdf_book:
    fig_caption: yes
    keep_tex: yes
    toc: yes
    toc_depth: 4
  # bookdown::word_document2:
  #   reference_docx: Tutorial_template.docx
  # bookdown::html_document2:
  #   toc: yes
  #   pandoc_args: [
  #     "--csl", "elsevier-vancouver.csl" 
  #     # , "--citation-abbreviations", "abbreviations.json"
  #   ]
always_allow_html: yes
bibliography: /Users/FAE/Dropbox/BibTeX/WorkingPapers-CohortModelsR.bib
geometry: margin=1in
header-includes:
- \usepackage{amsmath}
- \usepackage{float}
- \usepackage{setspace}\onehalfspacing
- \usepackage[printwatermark]{xwatermark}
- \newwatermark[allpages,color=gray!20,angle=45,scale=2,xpos=0,ypos=0]{DRAFT, Do Not Share}
keywords: "Markov models, state-transition models, decision models, Tutorial, R"
link-citations: yes
csl: sage-vancouver.csl
# https://github.com/citation-style-language/styles
site: bookdown::bookdown_site
tags:
- Markov models
- state-transition models
- decision models
- Tutorial
- R
abstract: |
  Decision models can synthesize evidence from different sources to provide estimates of long-term implications and the uncertainty around a decision. State-transition cohort models (STCM) are decision models commonly used in medical decision making. In this tutorial, we provide a conceptualization of STCM in a programming language environment and show examples of how to implement them in R. We describe of the cost-effectiveness analysis of a new treatment using a previously published testbed STCM. We then describe the conceptualization of both time-homogeneous and time-dependent STCM of the testbed model and its implementation in R. For the time-dependent STCM, we consider both age- and history-dependency. We also describe how to retrieve certain intermediate epidemiological outcomes of interest. We conclude by demonstrating how to calculate economic outcomes and conducting a cost-effectiveness analysis of a new treatment compared to usual care. To provide transparency in model building, we provide a link to a public repository with all the code described in this tutorial that could be easily modified to different decision models.
---
```{r, echo = FALSE}
## Journal Abbreviations
# library(RJSONIO)
# if(!file.exists("abbreviations.json")){
# download.file("https://ndownloader.figshare.com/files/5212423","wos_abbrev_table.csv")
#   abbrev <- read.csv("wos_abbrev_table.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
#   abbrev$full <- gsub("\\", "\\\\",abbrev$full, fixed = TRUE)
#   abbrev.list <- list('default' = list('container-title' = abbrev$abbrev.dots))
#   names(abbrev.list$default$`container-title`) = abbrev$full
#   write(toJSON(abbrev.list), "abbreviations.json")
#   rm(abbrev)
#   rm(abbrev.list)
# }
```

```{r setup, include=FALSE}
library(knitr)
library(kableExtra) # https://haozhu233.github.io/kableExtra/awesome_table_in_html.html
library(dplyr)
library(reshape2)
library(ggplot2)
library(scales) # For dollar signs and commas
library(tensorA) # to use tensor algebra
knitr::opts_chunk$set(echo = TRUE)
doc.type <- knitr::opts_knit$get('rmarkdown.pandoc.to')
age     <- 25         # age at baseline
max.age <- 110         # maximum age of follow up
n.t <- max.age - age # time horizon, number of cycles
# v.r.mu <- seq(0.001, 0.01, length.out = 100)
lt.usa.2005 <- read.csv("../data/LifeTable_USA_Mx_2015.csv")
v.r.mu <- lt.usa.2005 %>% 
  # filter(Age >= age & Age <= max.age) %>%
  select(Total) %>%
  as.matrix()
```

```{r figure-setup, echo=FALSE, include=FALSE}
## chunk will ensure that:
library(formatR)
# indent = 2: two spaces of indentation.
# tidy=TRUE puts formatR to work to produce a beautiful and standardized layout code.
if(!knitr:::is_html_output())
{
  # options("width"=56)
  knitr::opts_chunk$set(tidy.opts=list(indent = 1.5)) # width.cutoff=56, tidy = TRUE
  knitr::opts_chunk$set(fig.pos = 'H')
}

## chunk will ensure that:
# all the figures generated by the report will be placed in the figs/sub-directory
# all the figures will be 6.5 x 4 inches and centered in the text.
knitr::opts_chunk$set(fig.path="../figs/", fig.width=6.5, fig.height=4, fig.align="center")
```

# Introduction

Healthcare policy makers are faced with decisions on how to allocate healthcare resources under constrained budgets and often use health economic evaluations to inform recommendations on the optimal strategy or policy. These recommendations often rely on the projected long-term implications each strategy. Decision models can synthesize evidence from different sources to estimate long-term outcomes and uncertainty around a decision. A commonly used decision model is the state-transition cohort model (STCM), often called a Markov model.[@Kuntz2017]

As the field of decision modeling advances, more complex models are being developed to better capture the underlying clinical and system complexity. More and more, these new modeling methodologies rely heavily on statistical and mathematical techniques. For example, Bayesian approaches are more frequently employed for some of the components of decision modeling (e.g., model calibration, value of information, evidence synthesis). Current commercially available software provide limited flexibility in embedding such complex statistical approaches within the decision model framework and are typically less computationally efficient than programming languages.[@Hollman2017] Furthermore, policy decisions are increasingly required to employ transparent decision processes; however model transparency and reproducibility in these software are often compromised due to inadequate documentation and the need to own a commercial software license.

Modern programming languages like R,[@RCoreTeam2018] provide a flexible and open-source environment where frequentist and Bayesian statistical analyses can be combined with decision models within the same framework. In addition, R can accommodate more complex model structures and improve computational times compared to commercially available software.[@Hollman2017] Finally, the fact that R is freely available improves model transparency and reproducibility, which is highly relevant to conduct cost-effectiveness analyses (CEAs) for regulatory or policy decisions.[@Cohen2017; @Jansen2017; @Dunlop2017; @InternationalSocietyforPharmacoeconomicsandOutcomesResearch2018; @Poole2007]

In a recent review of R modeling packages, we illustrated the increased utilization of the statistical programming framework R in health decision sciences and provided a collection of resources for its application in medical decision making.[@Jalal2017b] Despite its increasing use, no formal guidance exists on how to implement cohort-based decision models in a programming language. The purpose of this tutorial is twofold: (1) to conceptualize STCMs in a programming language, and (2) to provide guidance on how to implement these STCMs in an R environment. Note that this general conceptualization would apply to other programming languages (e.g., MatLab, Python, C++, etc.)
<!-- A number of economic evaluations that developed cohort-based decision models in R have been published in the past.[@Hawkins2005;@Hawkins2005a] (**ADD more citations**).  -->
<!-- The purpose of this tutorial is to provide decision modelers with a framework to implement cohort-based decision models in R.  -->We first provide a description of each of the components of a STCM and illustrate the implementation of these components with an illustrative example. The full code used in this tutorial is provided in the supplementary materials so that readers can replicate and modify the example to fit their needs. We also provide the most up-to-date code on GitHub (https://github.com/DARTH-git/). We note that the approach presented in this tutorial is not the only one to implement STCM in a programming language or R. It is assumed that the reader is familiar with the basics of decision modelling. A gentle introduction to R and to linear algebra for decision modelers can be found in supporting online materials. 
<!-- In this tutorial, we focus on the conceptualization and implementation of STCMs. In a future tutorial, we describe how to conduct deterministic and probabilistic sensitivity analyses.   -->

# State-transition models
STCMs are deterministic mathematical models that simulate hypothetical cohorts over time. A STCM consists of a set of $n_s$ mutually exclusive and collectively exhaustive health states. The cohort is assumed to be homogenous, differing only in their current health state. That is, all persons residing in a particular health state are indistinguishable from one another. The cohort can transition between these health states with defined probabilities, called transition probabilities. A transition probability represents the chance that individuals in the cohort residing in a state in any given cycle transition to another state or remain in the same state for the next cycle. Transition probabilities only depend on the current health state at any given cycle and cannot depend on the history prior to that cycle, which is often referred to as the "Markovian assumption".[@Kuntz2001; @Sonnenberg1993; @Beck1983] If the decision problem can be described with a reasonable number of health states, a STCM could be chosen because of its "transparency, efficiency, ease of debugging and ability to conduct specific value-of-information analyses".[@Siebert2012c] STCMs have been used to evaluate screening programs, diagnostic procedures, disease management programs, and risk factor interventions.

STCMs are classified as either time-homogeneous or time-dependent. Time-homogeneous STCMs have constant transition probabilities, while time-dependent STCMs have transition probabilities that vary over time. Most problems in health care are best modeled with a time-dependent STCM, which can capture the increasing age-specific background mortality as the cohort ages and dependency on the amount of time spent in a given state. In this tutorial, we will cover both types.

STCMs can be evaluated in either discrete or continuous time. In discrete-time models, the cohort transitions at fixed time intervals, while continuous-time models assume that the cohort transitions between health states continuously over time according to some transition intensity. This tutorial focuses only on the discrete-time implementations.

In the next sections, we will illustrate the conceptualization and implementation of a STCM to conduct a CEA using an illustrative example. Researchers can easily then customize this application to their own needs.

# Case study: Sick-Sicker model
We illustrate the implementation of a STCM for a CEA using a previously published 4-state Sick-Sicker model.[@Enns2015e] The model is used to quantify the expected costs and quality-adjusted life years (QALYs) for individuals with a hypothetical disease with two different stages, "Sick" and "Sicker". We then evaluate the cost-effectiveness of a hypothetical treatment that increases quality of life (QoL) in one of the disease states.[@Krijkamp2018] We use the Sick-Sicker model to illustrate both time-homogeneous and time-dependent STCMs. For the time-dependent model, we first consider age dependency and expand it to also account for history-dependence. 

In the Sick-Sicker model, we simulate a hypothetical cohort of 25-year-old individuals over a lifetime (or reaching age 110 years old) that all start in the "Healthy" health state (denoted "H"). That is, the total number of cycles, $n_t$ represented with `n.t` is `r n.t`. Healthy individuals are at risk of developing the illness, at which point they would transition to the first stage of the disease (the "Sick" health state, denoted "S1"). Individuals that become sick incur a one-time utility decrement of 0.01 (`du.HS1`, disutility of transitioning from H to S1) and a one-time cost of \$1,000 (`ic.HS1`) that reflect the acute impacts of developing the illness. Sick individuals are at risk of further progressing to a more severe stage (the "Sicker" health state, denoted "S2"), which in the time-homogenous model is constant and in the time-dependent model is a function of the duration of being in the Sick state. There is a chance that individuals in the Sick state eventually recover and return back to the Healthy state. However, once an individual reaches the Sicker health state, they cannot recover; that is, the probability of transitioning to the Sick or Healthy health states from the Sicker health state is zero. Individuals in the Healthy state face background mortality that could be either constant or age-specific (i.e., time-dependent). Sick and Sicker individuals face an increased mortality in the form of a hazard ratio (HR) of 3 and 10 times, respectively, on the background mortality rate. Sick and Sicker individuals also experience increased health care costs and reduced QoL compared to healthy individuals. Once simulated individuals die, they transition to the "Dead" health state (denoted "D"), where they remain. When an individual dies, they incur a one-time cost of $2,000 (`ic.D`) that reflects the acute care that might be received immediately preceding death. The state-transition diagram of the Sick-Sicker model is shown in Figure \@ref(fig:STD-Sick-Sicker). The evolution of the cohort is simulated in one-year discrete-time cycles. Both costs and QALYs are discounted at an annual rate of 3%.

```{r STD-Sick-Sicker, echo=FALSE, fig.cap="State-transition diagram of the Sick-Sicker state-transition model with the name of the states, state rewards (utilities and costs) and transition probabilities. For the time-dependent version of the STCM, we allow p.HD, p.S1D and p.S2D to be age-dependent and p.S1S2 to be time-dependent", fig.pos="H"}
knitr::include_graphics("../Diagrams/Markov-Diagram-Sick-Sicker.pdf") 
```

We are interested in evaluating the cost-effectiveness of a hypothetical new treatment for individuals affected with the illness compared to usual care (the status quo). The treatment costs $12,000 per year (`c.Trt`). The effect of this new treatment is an increase in the QoL of individuals in the Sick state from a utility of 0.75 (without treatment, `u.S1`) to a utility of 0.95 (`u.Trt`). It does not have any impact on the QoL of individuals in the Sicker state, nor does it change the risk of becoming sick or progressing through the sick states. However, we assume that it is not possible to distinguish between Sick and Sicker patients; therefore, individuals in both sick states receive the treatment until they either recover to the Healthy state or die. Note that the STCM for the new treatment is structurally identical to that of the usual-care strategy and the only difference is the added cost of the treatment for those in the Sick or Sicker state and the increase in QoL for those in the Sick state. After comparing the two strategies in terms of QALYs and costs, we calculate the incremental cost per QALY gained of treatment compared to usual care. 

<!-- The annual costs in the Healthy, Sick, Sicker and Dead states (`c.H`, `c.S1`, `c.S2` and `c.D`, respectively) will be the same for both strategies.  -->
All the parameters of the Sick-Sicker model and the corresponding R variable names are presented in Table \@ref(tab:param-table).

<!-- Source of table: https://www.tablesgenerator.com/markdown_tables# -->

Table: (\#tab:param-table) Description of parameters with their R name and value.

|           **Parameter**            |  **R name** |   **Value**   |
|:-----------------------------------|:-----------:|:-------------:|
| Time horizon ($n_t$)               | `n.t`       | `r n.t` years |
| Names of health states ($n$)       | `v.n`       | H, S1, S2, D  |
| Annual discount rate (costs/QALYs) | `d.c`/`d.e` |  3%           |
| Annual transition probabilities    |             |               |
| - Disease onset (H to S1)          | `p.HS1`     |  0.15         |
| - Recovery (S1 to H)               | `p.S1H`     |  0.5          |
| - Disease progression (S1 to S2)  in the time-homogenous model   | `p.S1S2`    |  0.105        |
| - Time-dependent disease progression (S1 to S2) | `p.S1S2.tunnels` | |
|   &nbsp;&nbsp;&nbsp;&nbsp;Weibull parameters |         |               |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale ($\lambda$)             | `l`         |  0.08         |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape ($\gamma$)              | `g`         |  1.10         |
| Annual mortality                   |             |               |
| - All-cause mortality (H to D)     | `p.HD`      |  0.002 or age-specific |
| - Hazard ratio of death in S1 vs H | `hr.S1`     |  3            |
| - Hazard ratio of death in S2 vs H | `hr.S2`     |  10           |
| Annual costs                       |             |               |
| - Healthy individuals              | `c.H`       |  $2,000       |
| - Sick individuals in S1           | `c.S1`      |  $4,000       |
| - Sick individuals in S2           | `c.S2`      |  $15,000      |
| - Dead individuals                 | `c.D`       |  $0           |
| - Additional costs of sick individuals treated in S1 or S2           | `c.Trt`     |  $12,000      |
| Utility weights                    |             |               |
| - Healthy individuals              | `u.H`       |  1.00         |
| - Sick individuals in S1           | `u.S1`      |  0.75         |
| - Sick individuals in S2           | `u.S2`      |  0.50         |
| - Dead individuals                 | `u.D`       |  0.00         |
| Intervention effect                |             |               |
| - Utility for treated individuals in S1 | `u.Trt` |  0.95        |
| Transition rewards                 |             |               |
| - Utility decrement of healthy individuals | `du.HS1`|  0.01       |
|   when transitioning to S1         |             |               |
| - Cost of healthy individuals      | `ic.HS1` |  $1,000       |
|   when transitioning to S1         |             |               |
| - Cost of dying                    | `ic.D`      |  $2,000       |

Below, we show how to input the parameters in R. For the most up to date code, please visit https://github.com/DARTH-git/. We use the prefixes "`m.`" or "`v.`" to represent a matrix or a vector, respectively, consistent with our previous tutorial.[@Krijkamp2018]  In addition, we use the prefix "`a.`" to represent multidimensional arrays.

```{r Model-Params, eval=TRUE}
## General setup
age     <- 25         # age at baseline
max.age <- 110         # maximum age of follow up
n.t <- max.age - age # time horizon, number of cycles
v.n <- c("H", "S1", "S2", "D") # the 4 health states of the model:
                               # Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.s <- length(v.n) # number of health states 
d.c <- d.e <- 0.03 # equal discount of costs and QALYs by 3%
v.names.str <- c("Usual care", "New treatment") # store the strategy names

## Transition probabilities (per cycle)
p.HD    <- 0.002 # constant probability of dying when Healthy (all-cause mortality)
p.HS1   <- 0.15  # probability to become Sick when Healthy
p.S1H   <- 0.5   # probability to become Healthy when Sick
p.S1S2  <- 0.105 # probability to become Sicker when Sick
hr.S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr.S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

## Cost and utility inputs 
# State rewards
c.H   <- 2000  # cost of remaining one cycle Healthy 
c.S1  <- 4000  # cost of remaining one cycle Sick 
c.S2  <- 15000 # cost of remaining one cycle Sicker 
c.D   <- 0     # cost of being dead (per cycle)
c.Trt <- 12000 # cost of treatment (per cycle) 

u.H   <- 1     # utility when Healthy 
u.S1  <- 0.75  # utility when Sick 
u.S2  <- 0.5   # utility when Sicker
u.D   <- 0     # utility when Sealthy 
u.Trt <- 0.95  # utility when being treated

# Transition rewards
du.HS1 <- 0.01  # disutility when transitioning from Healthy to Sick
ic.HS1 <- 1000  # increase in cost when transitioning from Healthy to Sick
ic.D   <- 2000  # increase in cost when dying
```

To compute the mortality risks from the Sick and Sicker states, we transform `p.HD` to a rate assuming a constant exponential rate, `-log(1 – p.HD)`, multiply it by the hazard ratios `hr.S1` and `hr.S2`, respectively, and then convert them back to a probability. See the R code below for more details on the calculations.

```{r Sick-Sicker-Params, eval=TRUE}
p.S1D  <- 1 - exp(log(1 - p.HD) * hr.S1) # probability of dying in Sick
p.S2D  <- 1 - exp(log(1 - p.HD) * hr.S2) # probability of dying in Sicker
```

<!-- Below, we provide a description on how to construct the Sick-Sicker STCM in R. -->

# Constructing a STCM
There are multiple approaches to construct a STCM. The most common approaches are via a set of difference equations [@Grimmett2014; @Axler2005] or a representation of these equations through a matrix formulation.[@Grimmett2014; @Axler2005; @Sonnenberg1993; @Beck1983] In this tutorial, we will only focus on the matrix formulation.
<!-- , but a difference equation approach is described in Appendix XX. -->

<!-- ## Methods of evaluation -->

<!-- ### Difference-equation formulation -->
<!-- Solution is iterative -->

<!-- ## Matrix formulation -->
In general, a matrix formulation of STCM consists of four core components: (1) a state vector, $s_t$, that stores the distribution of the cohort across all health states in cycle $t$ where $t = 0,\ldots, n_t$, (2) the cohort trace matrix, $M$, that *traces* the distribution of the cohort over time and is simply the collection of $s_t$ for all $t$, and (3) a transition probability matrix, $P_t$.[@Iskandar2018] If the STCM is comprised of $n_s$ discrete health states, $s_t$ is a $1 \times n_s$ vector and $P_t$ is a $n_s \times n_s$ matrix. The $i$-th element of $s_t$ represents the proportion of the cohort in the $i$-th health state in cycle t, referred to as $s_t[i]$. The elements of $P_t$ could be transition probability functions of time $t$ of going from state $i$ to state $j$, $p(t)_{i,j}$, where $\{i,j\} \in 1\ldots n_s$ and $t = 0,\ldots,n_t$. 
$$
  P_t = 
  \begin{bmatrix}
    p(t)_{1,1} & p(t)_{1,2} & \cdots & p(t)_{1, n_s} \\
    p(t)_{2,1} & p(t)_{2,2} & \cdots & p(t)_{2, n_s} \\
    \vdots    & \vdots  & \ddots & \vdots   \\
    p(t)_{n_s,1} & p(t)_{n_s,2} & \cdots & p(t)_{n_s, n_s} \\
  \end{bmatrix}
$$
Note that all rows of the transition probability matrix in each cycle $t$ must sum to one, $\sum_{j=1}^{n_s}{p(t)_{i,j}} = 1$ for all $i = 1,\ldots,n_s$ and $t = 0,\ldots, n_t$.

The state vector at cycle $t+1$, $s_{t+1}$ is then calculated by the inner product of the state vector at cycle $t$, $s_{t}$, and the transition probability matrix that the cohort faces in cycle $t$, $P_t$. Formally,

$$
  s_{t+1} = s_{t} P_t \text{ for } t = 0,\ldots, n_t - 1
$$
<!-- The state vector at cycle $t+1$, $s_{t+1}$, is only determined by $s_t$ and $P_t$ through their inner product. Formally, -->
<!-- $$ -->
<!--   s_{t+1}=s_t P_t, -->
<!-- $$ -->
where $s_t$ is initialized at $s_0$, which represents the initial state vector with the proportion of the cohort distributed across all health states in cycle 0.

The cohort trace matrix, $M$, is a matrix of dimensions $(n_t+1) \times n_s$ where each row, $t$, stores the state vector $s_{t-1}$

$$
  M = 
  \begin{bmatrix}
    - s_0 -      \\
    - s_1 -      \\
    \vdots   \\
    - s_{n_t} - \\
  \end{bmatrix}.
$$
$M$ is a commonly used matrix to store the output of STCM, which could be used to produce epidemiological outcomes, such as prevalence and survival, and economic outcomes, such as cumulative resource use and costs. To access the state vector, $s_t$, from the cohort trace matrix, we simply select the $t+1$ row of $M$. Note that we consider that the initial cycle corresponds to $t=0$, which is stored on the first row of $M$. Table \@ref(tab:STCM-components-table) shows a description of each of the core components of STCM and their suggested name in R code. 

Table: (\#tab:STCM-components-table) Components of STCM with their R name.

| Element | Description               | R name |   |
|---------|---------------------------|:------:|---|
| $s_t$   | State vector in cycle $t$ | `v.st` |   |
| $s_0$   | Initial state vector      | `v.s0`   |   |
| $M$     | Cohort trace matrix       | `m.M`  |   |
| $P$     | Time-homogeneous transition matrix| `m.P` |   |
| $P_t$   | Time-dependent transition array| `a.P` |   |
| $A$     | Transition array          | `a.A` |   |

For the Sick-Sicker model, the entire cohort starts in the Healthy state. Therefore, we create the initial state vector `v.s0` with all of the cohort assigned to the H state:
```{r Sick-Sicker-s0}
v.s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
v.s0
```
and use it to initialize $M$ represented by `m.M`
```{r Sick-Sicker-M}
# Initialize cohort trace
m.M <- matrix(0, 
              nrow = (n.t + 1), ncol = n.s, 
              dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.s0
```

Note that the initial state vector, `v.s0`, can be modified to account for a non-zero prevalence of the disease at the start of the simulation.

## Time-homogeneous STCM
In a time-homogeneous STCM, transition probabilities are constant (i.e., do not vary over time). Thus,

$$
  P_t = P = 
  \begin{bmatrix}
    p_{1,1}   & p_{1,2}   & \cdots & p_{1, n_s} \\
    p_{2,1}   & p_{2,2}   & \cdots & p_{2, n_s} \\
    \vdots    & \vdots    & \ddots & \vdots   \\
    p_{n_s,1} & p_{n_s,2} & \cdots & p_{n_s, n_s} \\
  \end{bmatrix} \text{ for } t = 0,\ldots, n_t
$$
and $s_{t+1} = s_tP$.

Since the Sick-Sicker model consists of `r n.s` states, we create a `r n.s` $\times$ `r n.s` transition probability matrix, `m.P`. We initialize the matrix with default values of zero for all transition probabilities and then populate each of its elements with the corresponding non-zero transition probability values. To access an element of `m.P`, we specify first the row number (or name) and then the column number (or name) separated by a comma. For example, the transition probability of going from state Healthy (H) to state Sick (S1) could be accessed as `m.P[1, 2]` or by using the corresponding row/column state names as characters `m.P["H", "S1"]`.

```{r Sick-Sicker-P2}
# Initialize matrix
m.P <- matrix(0, 
              nrow = n.s, ncol = n.s, 
              dimnames = list(v.n, v.n))
# Fill in matrix
# From H
m.P["H", "H"]   <- 1 - (p.HS1 + p.HD)
m.P["H", "S1"]  <- p.HS1
m.P["H", "D"]   <- p.HD
# From S1
m.P["S1", "H"]  <- p.S1H
m.P["S1", "S1"] <- 1 - (p.S1H + p.S1S2 + p.S1D)
m.P["S1", "S2"] <- p.S1S2
m.P["S1", "D"]  <- p.S1D
# From S2
m.P["S2", "S2"] <- 1 - p.S2D
m.P["S2", "D"]  <- p.S2D
# From D
m.P["D", "D"]   <- 1
```

<!-- Let $s_t$ be a row vector of size $1\times n_s$ that represents the distribution of the cohort at time $t$, called state vector from now on. The $i$-th  element of $s_t$ represents the proportion of the cohort in the $i$-th health state, that we would refer to as $s_t[i]$. The inner product of $s_{t}$ and $P$ produces the distribution of the cohort at the next cycle, $s_{t+1}$. More formally, this relationship is expressed by -->
<!-- $$ -->
<!--   s_{t+1} = s_{t} P. -->
<!-- $$ -->

<!-- By combining all the state vectors $s_t$ for $t = 0,\ldots,n_t$, we create the so-called cohort trace matrix, $M$, which is a matrix of dimensions $(n_t+1) \times n_s$ where each of its rows is a state vector -->

<!-- $$ -->
<!--   M =  -->
<!--   \begin{bmatrix} -->
<!--     s_0      \\ -->
<!--     s_1      \\ -->
<!--     \vdots   \\ -->
<!--     s_{n_t}  \\ -->
<!--   \end{bmatrix}. -->
<!-- $$ -->

<!-- The cohort trace matrix, $M$, stores the proportion of the cohort across all $n_s$ health states in cycle $t$ in it's $t+1$ row where $t = 0, \ldots, n_t$. That is, $M$ is the collection of state vectors and provides information over time of the distribution of the cohort across states over time. $M$ is a commonly used matrix to store the output of STCM, which could be used to produce epidemiological outcomes, such as prevalence, survival, incidence, and economic outcomes, such as cumulative resource use and costs. To access the state vector, $s_t$, from the cohort trace matrix, we simply select the $t+1$ row of $M$. Note that we consider that the initial cycle corresponds to $t=0$, which is stored on the first row of $M$.  -->

<!-- We can reformulate the previous matrix multiplication in terms of the cohort trace matrix $M$ as follows  -->
<!-- $$ -->
<!--   M_{t+1} = M_{t} P -->
<!-- $$ -->

To simulate the cohort in the Sick-Sicker model over `r n.t` cycles using a time-homogeneous STCM, we iterate the inner product between `m.M` and `m.P` using the inner product `%*%` symbol in R at each cycle using a `for` loop

```{r Sick-Sicker-TimeHomogeneous-Solution}
# Iterative solution of time-homogeneous STCM
for(t in 1:n.t){
  m.M[t + 1, ] <- m.M[t, ] %*% m.P
}
```

Table \@ref(tab:Trace) shows the cohort trace matrix of the Sick-Sicker model for the first six cycles. The whole cohort starts in the Healthy state and transitions to the rest of the health states over time. Given that the Dead state is an absorbing state, the proportion in this state increases over time. A graphical representation of the cohort trace for all the cycles is shown in Figure \@ref(fig:Sick-Sicker-Trace-TimeHom).


```{r Trace, echo=FALSE, message=FALSE, warning=FALSE}
kable(head(round(m.M, 3)), 
      format = ifelse(doc.type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "First six cycles of the cohort trace of time-homogeneous Sick-Sicker model",
      align = c("c", "c", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

```{r Sick-Sicker-Trace-TimeHom, echo=FALSE, fig.cap='Cohort trace of time-homogeneous STCM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2, linetype = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state") +
  scale_linetype_discrete(name = "Health state") +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme()
# matplot(m.M, pch = v.n)
```

<!-- To compute the cohort trace matrix $M$ in R, we need to initialize a matrix \texttt{P}. We then use the transition matrix \texttt{P}, and the initial state vector for time $t=0$ (\texttt{v.s0}) to compute the state vector over all $T+1$ times. To extract the prevalence of say, state 2 (\texttt{prev2}), we just need the second column of \texttt{ST}. -->

## Time-dependent STCM
Time-dependency in STCMs can occur in at least two forms: (1)  time-dependency that affects the whole cohort the same way (e.g., age-specific background mortality) 
<!-- In this tutorial we will only cover the second form of time dependency, which solutions in R have been previously proposed.[@Hawkins2005]  -->
and (2) dependence on the amount of time spent in a state (i.e., history-dependence).
<!-- To readers interested in the first form, we refer to the article by Hawkins et al., 2005.[@Hawkins2005] -->
In the next sections, we describe both types of time-dependency and provide a description of their implementation in R.

### Time dependency that affects the whole cohort
Time-dependency in the transition probabilities that affect the whole cohort is accounted by the transition probability matrix being a function of time, $P_t$. 
<!-- That is, the elements of $P_t$ are transition probabilities from state $i$ to state $j$ that the cohort faces in cycle $t$, $p(t)_{i,j}$, where $\{i,j\} = 1,\ldots, n_s$ and $t = 0,\ldots,n_t$ -->

<!-- The state vector at cycle $t+1$, $s_{t+1}$ is then calculated by the inner product of the state vector at cycle $t$, $s_{t}$, and the transition probability matrix that the cohort faces in cycle $t$, $P_t$ -->

<!-- $$ -->
<!--   s_{t+1} = s_{t} P_t -->
<!-- $$ -->

<!-- Note that all rows of the transition probability matrix in each cycle $t$ must sum to one, $\sum_{i=1}^{n_s}{p(t)_{i,j}} = 1$ for all $j = 1,\ldots,n_s$ and $t = 0,\ldots, n_t$. -->

To illustrate the implementation of time-dependency in the Sick-Sicker STCM, we assume that all-cause mortality is a function of age. It is common to obtain all-cause mortality from life tables in the form of age-specific mortality rates, $\mu(a)$, where $a$ refers to the age index. For this example, we create a vector `v.r.mu` of length $n_t$ with the age-specific background mortality rates obtained from the 2015 US life-tables[@Arias2017], corresponding to the age of the cohort at each time step. To compute the transition probability from Healthy to Dead for the Sick-Sicker model, we need to transform $\mu(a)$ to a transition probability assuming constant exponential rate within each year of age

$$
  p(t)_{H,D} = 1-\exp\left\{{-\mu(a_0 + t)}\right\},
$$ 
where $a_0 = 25$ is the starting age of the cohort. We will run the Sick-Sicker model for `r n.t` cycles; therefore, we select the background mortality rates for ages 25 to 110 by correctly indexing the `v.r.mu`. Thus, the variable in R is constructed as

```{r}
p.HDage  <- 1 - exp(-v.r.mu[(age + 1) + 0:(n.t - 1)]) # age-specific probability of dying
                                                    # when Healthy (all-cause mortality)
```

Because the mortality risks in the Sick and Sicker health states are defined relative to the background mortality risk in the Healthy state, adding age-dependency on background mortality results in an age-dependence in the mortality from each stage of illness. To generate the age-specific mortality for all cycles, we multiply the age-specific background mortality rate, `v.r.mu`, by the constant hazard ratios `hr.S1` and `hr.S2`, respectively, and then convert the resulting stage-specific mortality rates to probabilities as described previously. 

```{r}
p.S1Dage <- 1 - exp(-v.r.mu[(age + 1) + 0:(n.t - 1)] * hr.S1) # age-specific prob to die in Sick
p.S2Dage <- 1 - exp(-v.r.mu[(age + 1) + 0:(n.t - 1)] * hr.S2) # age-specific prob to die in Sicker
```

One way to incorporate age-dependency into $P_t$, is to create a transition probability array, `a.P`, of dimensions $n_s \times n_s \times n_t$, where the first two dimensions correspond to transitions between states and the third dimension to time. That is, the $t$-th element in the third dimension corresponds to the transition probability matrix at cycle $t$. A visual representation of `a.P` is shown in Figure \@ref(fig:Array-Time-Dependent).

```{r Array-Time-Dependent, echo=FALSE, fig.cap="3-dimensional array of the time-dependent Sick-Sicker model where time-varying transition probabilities affect the whole cohort.", fig.pos="H"}
knitr::include_graphics("../figs/3D-state-transition-array-sick-sicker-without-tunnels.jpg")
```

First, let us initialize `a.P` with a default value of zero for all transition probabilities.
```{r Init-Sick-Sicker-TimeDep-P}
# Initialize array
a.P <- array(0, dim = c(n.s, n.s, n.t),
              dimnames = list(v.n, v.n, 0:(n.t - 1)))
```

Filling `a.P` with the corresponding transition probabilities is similar to the `m.P` above, with the difference being that we now refer to all the cycles by leaving the index of the third dimension blank.  This operation will complete the corresponding positions of `a.P` with the $n_t + 1$ vector of probabilities (when the transition probability varies over time)or with $n_t + 1$ replications of the probability (when the probability is constant over time).

```{r Sick-Sicker-TimeDep-P}
# Fill in array
# From H
a.P["H", "H", ]   <- 1 - (p.HS1 + p.HDage)
a.P["H", "S1", ]  <- p.HS1
a.P["H", "D", ]   <- p.HDage
# From S1
a.P["S1", "H", ]  <- p.S1H
a.P["S1", "S1", ] <- 1 - (p.S1H + p.S1S2 + p.S1Dage)
a.P["S1", "S2", ] <- p.S1S2
a.P["S1", "D", ]  <- p.S1Dage
# From S2
a.P["S2", "S2", ] <- 1 - p.S2Dage
a.P["S2", "D", ]  <- p.S2Dage
# From D
a.P["D", "D", ]   <- 1
```

As mentioned before, each of the elements on the third dimension of `a.P` correspond to a transition matrix. For example, the transition matrix for 25-year-olds in the Sick-Sicker model is shown below

```{r Transition-Probability-Array-1}
a.P[, , 1]
```

To simulate the cohort over the $n_t$ cycles for the time-dependent STCM, we initialize a new cohort trace matrix `m.M.td`

```{r Init-Sick-Sicker-TimeDependent-Trace}
# Initialize cohort for time-dependent (td) STCM
m.M.td <- matrix(0, 
                 nrow = (n.t + 1), ncol = n.s, 
                 dimnames = list(0:n.t, v.n))
m.M.td[1, ] <- v.s0
```

and then use the inner product. This is similar to the time-homogeneous model but we now also index the transition probability array `a.P` by $t$ to obtain the cycle-specific transition probability matrix, $P_t$.

```{r Sick-Sicker-TimeDependent-Solution}
# Iterative solution of time-dependent STCM
for(t in 1:n.t){
  m.M.td[t + 1, ] <- m.M.td[t, ] %*% a.P[, , t]
}
```

A graphical representation of the cohort trace for all cycles of the age-dependent STCM is shown in Figure \@ref(fig:Sick-Sicker-Trace-TimeDep). We should note that a number of alternative approaches can be applied in the incorporation of age-dependency in STCM. Other approaches involve the update of the time varying elements of the transition probability matrix $P_t$ at each time point $t$. That would alleviate the need for the construction of the array `a.P`. This reduces computer memory requirements, but at the expense of increasing the number of operations in the update of $P_t$ at every cycle. 

```{r Sick-Sicker-Trace-TimeDep, echo=FALSE, fig.cap='Cohort trace of the time-dependent STCM.', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(melt(m.M.td), aes(x = Var1, y = value, color = Var2, linetype = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state") +
  scale_linetype_discrete(name = "Health state") +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme()
```

### Time dependency based on the amount of time spent in a state
Transition probabilities can vary by the amount of time spent in a given state. That is, transition probabilities can be considered as history-dependent. One way to account for the dependency on the time spent in a state, is to expand the state space as much as needed. This expansion requires a series of transient states, referred to as *tunnel* states, in which the cohort cannot stay after a given cycle. Instead, the cohort has to advance to either the subsequent transient state or exit these expanded states.
To create tunnel states, we need to produce as many states as time-dependency is desired. For example, if dependency in a given state is assumed for $T$ cycles, the state needs to be expanded $T$ times. This will generate an expanded transition probability matrix (or array) of dimensions $n_{s_{T}} \times n_{s_{T}}$ (or $n_{s_{T}} \times n_{s_{T}} \times n_t$), where $n_{s_{T}}$ is the total number of health states after accounting for the expansion of a given state for $T$ tunnel states. History-dependency could occur for as many cycles as the STCM is simulated; therefore, is such cases $T=n_t$. Figure \@ref(fig:STD-Sick-Sicker-tunnels) shows the state-transition diagram of the Sick-Sicker model that includes history dependence with tunnel states for S1.
 
```{r STD-Sick-Sicker-tunnels, echo=FALSE, fig.cap="State-transition diagram of the Sick-Sicker model with tunnel states expanding the Sick state ($S1_1, S1_2,...,S1_{\tau}$).", fig.pos="H"}
knitr::include_graphics("../figs/Sick-Sicker with tunnels.jpg")
```


To build history-dependency in the age-dependent Sick-Sicker model defined above, we assumed that the risk of progression from Sick to Sicker increases the longer a person has been sick. This increase follows a Weibull growth curve, calculated as 
$$
  p(t)_{S1_{\tau},S2} = \lambda \gamma \tau^{(\lambda-1)},
$$
where $\tau = 1, \ldots, T$ is the $\tau$-th cycle (year) that a person has been in the Sick state, and $\lambda$ and $\gamma$ are the scale and shape parameters of the Weibull function, respectively. We assume that history-dependency occurs throughout the whole simulation (i.e., $T=n_t$) and create a new variable called `tunnel.size` with the length of the tunnel equal to `n.t`. Thus, the number of states will be `r n.t` S1 tunnel states plus 3 more states (H, S2, D) for a total of $n_{s_{T}}$ = `r (n.s-1) + n.t`. 

To implement the history-dependent Sick-Sicker model with tunnels, we create four new parameters: (1) `v.Sick.tunnel`, a variable with the tunnel names of the Sick state, (2) `v.n.td`, a vector with state names including tunnel states, (3) `n.s.td`,  a variable with the number of states including the expanded names for the tunnel states, and (4), `v.s0.tunnels`, an initial state vector for the model with tunnels that it represents. Table \@ref(tab:STCM-tunnels-table) shows the extra R variables for the history-dependent Sick-Sicker model with tunnels

Table: (\#tab:STCM-tunnels-table) Table of new R variables for the history-dependent Sick-Sicker model with tunnels.

| R name  | Description               |
|---------|---------------------------|
| `v.Sick.tunnel` | vector with the the tunnel names of the Sick state |
| `v.n.td`      | vector with state names including tunnel states  |
| `n.s.td`      | number of states including tunnel states|
| `v.s0.tunnels`  | initial state vector for the model with tunnels |

```{r}
tunnel.size <- n.t # Number of tunnels
# Name for tunnels states of Sick state
v.Sick.tunnel <- paste("S1_", seq(1, tunnel.size), "Yr", sep = "")
# Create variables for model with tunnels
v.n.td  <- c("H", v.Sick.tunnel, "S2", "D") # state names
n.s.td  <- length(v.n.td)                   # number of states
# Initialize first cycle of Markov trace accounting for the tunnels
v.s0.tunnels <- c(1, rep(0, tunnel.size), 0, 0) 
```

Based on the updated parameters, the history-dependent transition probability from Sick to Sicker based on a Weibull function, `p.S1S2.tunnels`, is defined
```{r}
# Weibull parameters
l <- 0.08 # scale
g <- 1.1  # shape
# Weibull function
p.S1S2.tunnels <- l * g * (1:tunnel.size)^{g-1}
```

To implement the transition probability array for the age- and history-dependent Sick-Sicker model, we create an expanded 3-dimensional array accounting for tunnels `a.P.tunnels` of dimensions $n_{s_T} \times n_{s_T} \times n_t$, where $n_{s_T}$  `r n.s.td`, the number of states of the Sick-Sicker model with tunnels. A visual representation of `a.P.tunnels` of the Sick-Sicker model with tunnel states expanding the Sick state is shown in Figure \@ref(fig:Array-Time-Dependent-Tunnels)

```{r Array-Time-Dependent-Tunnels, echo=FALSE, fig.cap="3-dimensional array of the time-dependent Sick-Sicker model where time-varying transition probabilities affect the whole cohort with tunnel states expanding the Sick state.", fig.pos="H"}
knitr::include_graphics("../figs/3D-state-transition-array-sick-sicker-tunnels.jpg")
```

```{r Init-Sick-Sicker-TimeDep-P-tunnels}
# Initialize array
a.P.tunnels <- array(0, dim = c(n.s.td, n.s.td, n.t),
                     dimnames = list(v.n.td, v.n.td, 0:(n.t - 1)))
```

Filling `a.P.tunnels` with the corresponding transition probabilities is similar to the `a.P` above, with the difference being that we now fill the transition probabilities from all the tunnel states of the Sick state by iterating through all the tunnel states and assigning the corresponding disease progression transition probability. 

```{r Sick-Sicker-TimeDep-P-tunnels}
# Fill in array
# From H
a.P.tunnels["H", "H", ]              <- 1 - (p.HS1 + p.HDage)
a.P.tunnels["H", v.Sick.tunnel[1], ] <- p.HS1
a.P.tunnels["H", "D", ]              <- p.HDage
# From S1
for(i in 1:(tunnel.size - 1)){
  a.P.tunnels[v.Sick.tunnel[i], "H", ]  <- p.S1H
  a.P.tunnels[v.Sick.tunnel[i], 
              v.Sick.tunnel[i + 1], ]   <- 1 - (p.S1H + p.S1S2.tunnels[i] + p.S1Dage)
  a.P.tunnels[v.Sick.tunnel[i], "S2", ] <- p.S1S2.tunnels[i]
  a.P.tunnels[v.Sick.tunnel[i], "D", ]  <- p.S1Dage
}
# repeat code for the last cycle to force the cohort stay in the last tunnel stateof Sick
a.P.tunnels[v.Sick.tunnel[tunnel.size], "H", ]  <- p.S1H
a.P.tunnels[v.Sick.tunnel[tunnel.size],
            v.Sick.tunnel[tunnel.size], ]       <- 1 - (p.S1H + p.S1S2.tunnels[tunnel.size] + p.S1Dage)
a.P.tunnels[v.Sick.tunnel[tunnel.size], "S2", ] <- p.S1S2.tunnels[tunnel.size]
a.P.tunnels[v.Sick.tunnel[tunnel.size], "D", ]  <- p.S1Dage
# From S2
a.P.tunnels["S2", "S2", ] <- 1 - p.S2Dage
a.P.tunnels["S2", "D", ]  <- p.S2Dage
# From D
a.P.tunnels["D", "D", ] <- 1
```

To simulate the cohort over the $n_t$ cycles for the time-dependent STCM with tunnels, we initialize a new cohort trace matrix `m.M.tunnels` of dimensions $n_t \times n_{S_T}$
<!-- `r n.t` $\times$ `r n.s.td` -->

```{r Init-Sick-Sicker-TimeDependent-Tunnels-Trace}
# Initialize cohort for time-dependent (td) STCM
m.M.tunnels <- matrix(0, 
                      nrow = (n.t + 1), ncol = n.s.td, 
                      dimnames = list(0:n.t, v.n.td))
m.M.tunnels[1, ] <- v.s0.tunnels
```

and then calculate inner product as with the time-dependent model

```{r Sick-Sicker-TimeDependent-Tunnels-Solution}
# Iterative solution of time-dependent STCM
for(t in 1:n.t){
  m.M.tunnels[t + 1, ] <- m.M.tunnels[t, ] %*% a.P.tunnels[, , t]
}
```
To compute a summarized cohort trace matrix to be comparable with the time-homogeneous and age-dependent STCM, we aggregate over the tunnel states for all cycles
```{r}
# Create aggregated trace
m.M.tunnels.sum <- cbind(H = m.M.tunnels[, "H"], 
                       S1 = rowSums(m.M.tunnels[, 2:(tunnel.size +1)]), 
                       S2 = m.M.tunnels[, "S2"],
                       D = m.M.tunnels[, "D"])
```

# Epidemiological and economic outputs
STCMs can be used to predict different epidemiological and economic outputs. In CEA, the final outcomes are typically the total QALYs and costs accrued in the cohort over the chosen time horizon. However, intermediate outcomes are often used for different purposes such as calibration and validation. The most common intermediate output are survival, prevalence, incidence, average number of events and lifetime risk events.[@Siebert2012c] Below, we provide the epidemiological definition of these intermediate outcomes and how they can be calculated from an STCM with the Sick-Sicker STCM.[@Krijkamp2018a]

## Survival curve
The survival curve, $S(t)$ is defined as the proportion of the population alive at cycle $t$. To estimate $S(t)$ from the simulated cohort of the age-dependent Sick-Sicker model, we sum the proportions of the non-death states for all $n_t$ cycles in `m.M.td`.
```{r Sick-Sicker-TimeDependent-Surv}
v.S.td <- rowSums(m.M.td[, -4]) # vector with survival curve
```

and is shown in Figure \@ref(fig:Sick-Sicker-Surv-TimeDep).

```{r Sick-Sicker-Surv-TimeDep, echo=FALSE, fig.cap='Survival curve of time-dependent STCM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 0:n.t, Survival = v.S.td), 
       aes(x = Cycle, y = Survival)) +
  geom_line(size = 1.3) +
  xlab("Cycle") +
  ylab("Proportion alive") +
  theme_bw(base_size = 16) +
  theme()
```

## Prevalence
Prevalence is defined as the proportion of the living population in a health state at risk of experiencing the disease at a given point in time.[@Rothman2008h] To calculate the prevalence of state $i$ at cycle $t$, $\text{prev}(t)_i$, we compute the ratio between the proportion of the cohort in state $i$ and the proportion alive at that cycle. The proportion of the cohort alive is simply given by the survival curve $S(t)$ defined above. The individual prevalence of the S1 and S2 health states, and the overall prevalence of sick individuals (i.e., S1 and S2) of the time-dependent Sick-Sicker STCM at each cycle $t$ is computed as follows

```{r Sick-Sicker-TimeDependent-Prevalence}
v.prev.S1   <- m.M.td[, "S1"] / v.S.td          # vector with prevalence of Sick
v.prev.S2   <- m.M.td[, "S2"] / v.S.td          # vector with prevalence of Sicker
v.prev.S1S2 <- rowSums(m.M.td[, c("S1", "S2")])/v.S.td # vector with prevalence of Sick and Sicker
```
and are shown in Figure \@ref(fig:Sick-Sicker-Prev-TimeDep).

```{r Sick-Sicker-Prev-TimeDep, echo=FALSE, fig.cap='Prevalence of sick states of time-dependent STCM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 0:n.t, 
                  States  = rep(c("S1", "S2", "S1 and S2"), each = (n.t + 1)), 
                  Prevalence = c(v.prev.S1, v.prev.S2, v.prev.S1S2)), 
       aes(x = Cycle, y = Prevalence, color = States, linetype = States)) +
  geom_line(size = 1.3) +
  scale_y_continuous(labels = scales::percent) + 
  scale_color_discrete(name = "Health States", l = 50) +
  scale_linetype(name = "Health States") +
  xlab("Cycle") +
  ylab("Prevalence (%)") +
  theme_bw(base_size = 16) +
  theme()
```

Another epidemiological outcome that could be of interest, is the proportion of Sicker (i.e., S2) among the sick individuals. To compute the proportion of S2 among all sick individuals at each cycle $t$, we simply divide $s_{t}[S2]$ by $\text{prev}(t)_{\{S1,S2\}}$ where $t>0$, as presented in Figure \@ref(fig:Sick-Sicker-PropS2-TimeDep). Note that $t$ does not start at 0 because it takes one cycle for the cohort to get sick.

```{r Sick-Sicker-TimeDependent-PropS2}
v.prop.S2 <- m.M.td[-1, "S2"] / v.prev.S1S2[-1] # vector with proportion of Sicker among sick individuals
```

```{r Sick-Sicker-PropS2-TimeDep, echo=FALSE, fig.cap='Proportion of Sicker (S2) individuals among all sick patients of time-dependent STCM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 1:n.t, 
                  Proportion = v.prop.S2), 
       aes(x = Cycle, y = Proportion)) +
  geom_line(size = 1.3) +
  # scale_y_continuous(labels = scales::percent) + 
  xlab("Cycle") +
  ylab("Proportion") +
  theme_bw(base_size = 16) +
  theme()
```


## Incidence
Disease incidence could be defined as the "number of new cases (incident number) divided by the person-time over a period".[@Rothman2008h] To compute the incidence of the disease states for the age-dependent Sick-Sicker model, we use the transition array $A$ that stores the transitions between all states of the STCM across all cycles. That is, $A$ is an object that contains all the information regarding the dynamics of STCM.[@Krijkamp2018a]

To compute the transition array $A$ of the time-dependent Sick-Sicker model, we initialize a three-dimensional array `a.A` of dimensions $n_s \times n_s \times n_t+1$ and set the diagonal of the first slice to the initial state vector `v.s0`.
```{r Init-Transition-Array}
# Initialize transition array
a.A <- array(0, 
             dim = c(n.s, n.s, n.t + 1),
             dimnames = list(v.n, v.n, 0:n.t))
# Set first slice of A with the initial state 
# vector in its diagonal
diag(a.A[, , 1]) <- v.s0
```

We then iterate the element by element multiplication between the array of transition matrices `a.P` and the cohort trace matrix, `m.M.td`, for each cycle to estimate each transition between all states over all $n_t$ cycles. 
```{r Compute-Transition-Array}
# Iterative solution to produce the transition array
for (t in 1:n.t){
  a.A[,, t + 1] <- m.M.td[t, ] * a.P[,, t]
}
```

To extract the incidence of going from state H to state S1, $\lambda_{H,S1}(t)$ (`v.l.HS1`), starting in $t=1$ we just need all the elements of `a.A` for that particular entry for all cycles and divide by the cohort at risk in the H state.

```{r Sick-Sicker-Incidence}
# Incidence from Healthy to state Sick
v.l.HS1 <- a.A["H", "S1", -1] / m.M.td[-(n.t + 1), "H"]
```

The cumulative incidence of transitioning from H to S1, `v.L.HS1` for the simulated cohort of the time-dependent Sick-Sicker STCM is computed with the cumulative sum of `v.l.HS1`

```{r Sick-Sicker-Cum-Incidence}
# Cumulative incidence from Healthy to state Sick
v.L.HS1 <- cumsum(v.l.HS1)
```
and is shown in Figure \@ref(fig:Sick-Sicker-CumInc-TimeDep).

```{r Sick-Sicker-CumInc-S1-TimeDep, echo=FALSE, eval=FALSE, fig.cap='Cumulative incidence of Sick (S1)', message=FALSE, warning=FALSE, fig.pos="H"} 
# ggplot(data.frame(Cycle = 1:30, CumInc = v.L.HS1), 
#        aes(x = Cycle, y = CumInc)) +
#   geom_line(size = 1.3) +
#   xlab("Cycle") +
#   ylab("Cumulative incidence") +
#   theme_bw(base_size = 16) +
#   theme()
```

To extract the incidence of becoming sicker, $\lambda_{,S2}(t)$ (`v.l.S2`), starting in $t=1$ we need the elements of `a.A` that determine  the probability of transitioning to S2 from S1 and divide by the cohort in the both the H and S1 states.

```{r Sick-Sicker-Incidence-S2}
# Incidence from Healthy and Sick to Sicker
v.l.S2 <- a.A["S1", "S2", -1] / sum(m.M.td[-(n.t + 1), c("H", "S1")])
```

The cumulative incidence of S2, `v.L.S2` for the simulated cohort of the time-dependent Sick-Sicker STCM is computed with the cumulative sum of `v.l.S2`
```{r Sick-Sicker-Cum-Incidence-S2}
# Cumulative incidence from Healthy and Sick to Sicker
v.L.S2 <- cumsum(v.l.S2)
```
and is shown in Figure \@ref(fig:Sick-Sicker-CumInc-TimeDep).

```{r Sick-Sicker-CumInc-S2-TimeDep, echo=FALSE, eval = FALSE, fig.cap='Cumulative incidence of S2', message=FALSE, warning=FALSE, fig.pos="H"} 
# ggplot(data.frame(Cycle = 1:30, CumInc = v.L.S2), 
#        aes(x = Cycle, y = CumInc)) +
#   geom_line(size = 1.3) +
#   xlab("Cycle") +
#   ylab("Cumulative incidence") +
#   theme_bw(base_size = 16) +
#   theme()
```

```{r Sick-Sicker-CumInc-TimeDep, echo=FALSE, fig.cap='Cumulative incidence of Sick (S1) and Sicker (S2).', message=FALSE, warning=FALSE, fig.pos="H"} 
df.CumInc <- data.frame(Cycle = 1:n.t, 
                        State = rep(c("Sick", "Sicker"), each = n.t),
                        CumInc = c(v.L.HS1, v.L.S2))
ggplot(df.CumInc, 
       aes(x = Cycle, y = CumInc)) +
  facet_wrap(~ State, scales = "free_y") +
  geom_line(size = 1.3) +
  xlab("Cycle") +
  ylab("Cumulative incidence") +
  theme_bw(base_size = 16) +
  theme()
```

## Life expectancy
Life expectancy (LE) refers to the expected number of years lived over a lifetime. LE is simply the area under the survival curve $S(t)$. In discrete time, is calculated as

$$
  LE = \sum_{t=0}^{\infty}{S(t)}.
$$

<!-- However, not all STCM are simulated over a lifetime but just over a specific number of cycles. In such cases, the area under the survival curve that corresponds to those cycles represents the expected life years (ELY) over a certain period. -->

<!-- $$ -->
<!--   ELY = \sum_{t=0}^{30}{S(t)} -->
<!-- $$ -->

```{r Expected-life-years-NoShow, echo=FALSE}
le.td <- sum(v.S.td)
```

For example, in the time-dependent Sick-Sicker model, where we simulated a cohort over `r n.t` cycles, life expectancy `le.td` is `r round(le.td, 1)`, which is calculated as follows

```{r Life-expectancy, eval=FALSE}
le.td <- sum(v.S.td) # life expectancy
le.td
```

# State and transition rewards
## State rewards
A state reward refers to a value assigned to individuals for being in a given state. In a cost-utility context, these could be either utilities or costs associated with remaining in a certain health state for a given cycle. The total expected reward of an outcome of interest for the entire cohort at each cycle could be stored in the vector $\Psi$ of size $(n_t+1)$. To calculate $\Psi$, we simply multiply the cohort trace matrix times a *vector* of state rewards $\omega$ of the same dimension as the number of states ($n_s$)
$$
  \Psi = M\omega.
$$
To get the total outcome of interest over the $n_t$ cycles, we sum the elements of $\Psi$. 

For the Sick-Sicker model, we need to create a vector of utilities and costs under usual care, `v.u.UC` and `v.c.UC`, respectively. Each of these vectors contain the utilities and costs corresponding with being in each of the four health states shown in Table \@ref(tab:param-table).

```{r State-rewards-UC}
## Vector of state utilities under usual care
v.u.UC <- c(H = u.H, S1 = u.S1, S2 = u.S2, D = u.D)
v.u.UC
## Vector of state costs under usual care
v.c.UC <- c(H = c.H, S1 = c.S1, S2 = c.S2, D = c.D)
v.c.UC
```

To create the state-reward vectors under the new treatment, we account for the benefits and costs of the new treatment. For the vector of utilities under new treatment, `v.u.Trt`, we substitute the utility of being in state S1 under usual care, `u.S1`, with the utility associated to the benefit of the treatment in being in that state, `u.Trt`.

```{r State-rewards-U-Tr}
## Vector of state utilities under new treatment
v.u.Trt <- c(H = u.H, S1 = u.Trt, S2 = u.S2, D = u.D)
v.u.Trt
```

To create the vector of state costs under the new treatment, `v.c.Tr`, we add the cost of treatment, `c.Trt`, to the state costs of S1 and S2.

```{r State-rewards-C-Tr}
## Vector of state costs under new treatment
v.c.Trt <- c(H = c.H, S1 = c.S1 + c.Trt, S2 = c.S2 + c.Trt, D = c.D)
v.c.Trt
```

To compute the expected QALYs and costs for the age-dependent Sick-Sicker model under usual care and new treatment for all cycles, we multiply the cohort trace matrix times these vectors
```{r Expected-outcomes-each-cycle}
## Vector of QALYs under usual care
v.qaly.UC <- m.M.td %*% v.u.UC
## Vector of costs under usual care
v.cost.UC <- m.M.td %*% v.c.UC
## Vector of QALYs under new treatment
v.qaly.Trt <- m.M.td %*% v.u.Trt
## Vector of costs under new treatment
v.cost.Trt <- m.M.td %*% v.c.Trt
```

To account for discounting, $\Psi$ is multiplied by a discounting vector $d$ of size $n_t+1$ where each of its $t$-th entry represents the discounting for cycle $t$ 
$$
  d = \left[0, \frac{1}{(1+r)^{1}}, \frac{1}{(1+r)^{2}}, \cdots, \frac{1}{(1+r)^{n_t}}\right],
$$
where $r$ is the cycle-length discount rate. Therefore, the total expected outcomes $E[O]$ are computed as
$$
 E[O] = \sum_{t=0}^{n_t}\Psi_t d_t,
$$
where $\Psi_t$ and $d_t$ correspond to the expected outcome and discount factor for cycle $t$, respectively.

The discount vectors for costs and QALYs for the Sick-Sicker model, `v.dwc` and `v.dwe`, respectively, are 

```{r Discount vectors}
# Discount weight (equal discounting is assumed for costs and effects)
v.dwe <- v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t)))  
```

The total expected discounted QALYs and costs under usual care and the new treatment are

```{r Expected-outcomes-all-cycles}
## Expected QALYs under usual care
qaly.UC <- sum(v.qaly.UC * v.dwe)
## Expected costs under usual care
cost.UC <- sum(v.cost.UC * v.dwc)
## Expected QALYs under new treatment
qaly.Trt <- sum(v.qaly.Trt * v.dwe)
## Expected costs under new treatment
cost.Trt <- sum(v.cost.Trt * v.dwc)
```

```{r Expected-outcomes, echo=FALSE, message=FALSE, warning=FALSE}
m.outcomes <- matrix(c(round(c(qaly.UC, qaly.Trt), 3),
                     c(dollar(c(cost.UC, cost.Trt)))),
                     ncol = 2, nrow = 2, 
                     dimnames = list(c("Usual care", "New treatment"),
                                     c("QALYs", "Costs")))
kable(m.outcomes, 
      format = ifelse(doc.type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Total expected discounted QALYs and costs of the age-dependent Sick-Sicker model under usual care and the new treatment", 
      align = c("l", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

The total expected QALYs and costs for the Sick-Sicker model under usual care and the new treatment are shown in Table \@ref(tab:Expected-outcomes). The total expected QALYs for usual care and the new treatment are `r round(qaly.UC, 3)` and `r round(qaly.Trt, 3)`, respectively. The total expected Costs for usual care and the new treatment are `r dollar(cost.UC)` and `r dollar(cost.Trt)`, respectively.

## Transition rewards
<!-- Note that not all transitions incur in a transition reward. A transition reward could represent a disutility associated to an event corresponding to a side-effect that individuals could experience while transitioning between health states. -->

<!-- In addition to the costs and utilities associated with being in a given state, a transition from one state to another may in of itself be associated with a one-time cost or utility impact, termed a "transition reward". For example, in the Sick-Sicker model, we can include a one-time cost of transitioning to the dead state that reflects the acute care that might be received immediately preceding death. This could include emergency services, hospitalization, or other healthcare utilization to address the ultimately fatal health complication. We also include a cost and utility decrement on the transition from the Healthy to Sick states. Whereas the cost and utility of the Sick state reflects the ongoing cost and utility of being chronically sick, these transition rewards capture the short-term (single cycle) impact of the acute events of becoming sick, such as hospitalization, stabilization, and so on. -->

In addition to rewards (e.g., costs and utilities) associated with being in a given state, a transition from one state to another may in of itself be associated with a one-time cost or utility impact, termed a "transition reward". For example, in the Sick-Sicker model, we previously mentioned that dying (i.e., transitioning to the dead state) incurs a one-time cost of `r dollar(ic.D)` that reflects the acute care that might be received immediately preceding death. This could include emergency services, hospitalization, or other healthcare utilization to address the ultimately fatal health complication. We also include a utility decrement and a cost increment on the transition from the Healthy to Sick states. Whereas the cost and utility of the Sick state reflects the ongoing cost and utility of being chronically sick, transition rewards capture the short-term (single cycle) impact of the acute events of becoming sick, such as hospitalization, stabilization, and so on.

When accounting for transition rewards, the total expected reward of an outcome of interest, $\Psi$, we need to replace the *vector* of state rewards $\omega$ with an *array* of rewards $\Omega$, and the cohort trace matrix, $M$, with the transition array, $A$. The array of rewards $\Omega$ is of dimensions $n_s \times n_s \times (n_t+1)$ and contains in its $i,j,t$-th element the transition rewards of going from state $i$ to state $j$ in cycle $t$, $\omega(t)_{i,j}$, in a given cycle. That is, at cycle $t$

$$
  \Omega_t = 
    \begin{bmatrix}
      \omega(t)_{1,1} & \omega(t)_{1,2} & \cdots & \omega(t)_{1,n_s} \\
      \omega(t)_{2,1} & \omega(t)_{2,2} & \cdots & \omega(t)_{2,n_s} \\
      \vdots  & \vdots  & \ddots & \vdots   \\
      \omega(t)_{n_s,n_s} & \omega(t)_{n_s,n_s} & \cdots & \omega(t)_{n_s,n_s} \\
  \end{bmatrix}
$$
That is, $\Omega_t$ allows for time-dependent state and transition rewards, such as age-specific utility weights. In the absence of transition rewards and with time-constant rewards, each row of $\Omega_t$ contains the state reward vector $\omega$. That is, 
$$
  \Omega_t = 
    \begin{bmatrix}
      \omega \\
      \omega \\
      \vdots \\
      \omega \\
  \end{bmatrix}
$$

However, in the presence of transition rewards, the corresponding elements of $\Omega_t$ should incorporate either an addition or subtraction (depending if the transition implies an increment or decrement in the rewards). 
<!-- Time-dependent transition rewards can be implemented in a similar approach to how time-dependency is incorporated to the STCM via a multidimensional array of transition rewards. -->

To calculate the total expected reward of an outcome of interest, $\Psi$ , accounting for transition rewards, we simply multiple element by element the cohort transition array, $A$ times the *array* of rewards $\Omega$
$$
  \Psi = A\Omega
$$

To create the matrix of rewards for costs and utilities for the Sick-Sicker STCM, we need to create strategy-specific matrices of rewards because the new treatment affects both outcomes. To illustrate the construction of the array of rewards for the new treatment strategy, we first create the arrays of utilities and costs based on the state utilities and costs, where each of the rows across the third dimension of these arrays are filled with the vector of state utilities.

```{r Init-Reward-Array}
## Array of utilities under new treatment
a.u.Trt <- aperm(array(v.u.Trt, 
                       dim = c(n.s, n.s, n.t + 1),
                       dimnames = list(v.n, v.n, 0:n.t)),
                 perm = c(2, 1, 3))
## Array of costs under new treatment
a.c.Trt <- aperm(array(v.c.Trt, 
                       dim = c(n.s, n.s, n.t + 1),
                       dimnames = list(v.n, v.n, 0:n.t)),
                 perm = c(2, 1, 3))
```

To account for the disutility of transitioning from H to S1, we subtract the disutility to the entry of the array of rewards corresponding to the transition from H to S1 across all cycles.

```{r Add-DisUtility}
# Add disutility due to transition from Healthy to Sick
a.u.Trt["H", "S1", ] <- a.u.Trt["H", "S1", ] - du.HS1
```

In a similar approach, we add the costs of transitioning from H to S1 and the cost of dying.

```{r Add-IncCosts}
# Add transition cost due to transition from Healthy to Sick
a.c.Trt["H", "S1", ] <- a.c.Trt["H", "S1", ] + ic.HS1
# Add transition cost of dying from all non-dead states
a.c.Trt[-n.s, "D", ] <- a.c.Trt[-n.s, "D", ] + ic.D
a.c.Trt[, , 1]
```

```{r Transition-reward-arrays, echo=FALSE}
### Transition rewards
## Array of state and transition utilities under usual care
a.u.UC <- aperm(array(v.u.UC, 
                       dim = c(n.s, n.s, n.t + 1),
                       dimnames = list(v.n, v.n, 0:n.t)),
                 perm = c(2, 1, 3))
# Add disutility due to transition from H to S1
a.u.UC["H", "S1", ] <- a.u.UC["H", "S1", ] - du.HS1

## Array of state and transition costs under usual care
a.c.UC <- aperm(array(v.c.UC, 
                       dim = c(n.s, n.s, n.t + 1),
                       dimnames = list(v.n, v.n, 0:n.t)),
                 perm = c(2, 1, 3))
# Add transition cost due to transition from H to S1
a.c.UC["H", "S1", ] <- a.c.UC["H", "S1", ] + ic.HS1
# Add transition cost of dying from all non-dead states
a.c.UC[-n.s, "D", ] <- a.c.UC[-n.s, "D", ] + ic.D
```

We now compute the expected costs and utilities by strategy per cycle by multiplying the transition array `a.A` times their corresponding array of rewards and then summing across all health states.

```{r}
#### Vectors of expected QALYs and costs per cycle ####
v.qaly.UC  <- rowSums(t(colSums(a.A * a.u.UC)))  # QALYs under usual care
v.cost.UC  <- rowSums(t(colSums(a.A * a.c.UC)))  # Costs under usual care
v.qaly.Trt <- rowSums(t(colSums(a.A * a.u.Trt))) # QALYs under new treatment
v.cost.Trt <- rowSums(t(colSums(a.A * a.c.Trt))) # Costs under new treatment
```

The total expected discounted (TED) costs and QALYs are 
```{r}
#### Total expected QALYs and Costs ####
ted.qaly.UC  <- sum(v.qaly.UC * v.dwe)  # Expected QALYs under usual care
ted.cost.UC  <- sum(v.cost.UC * v.dwc)  # Expected costs under usual care
ted.qaly.Trt <- sum(v.qaly.Trt * v.dwe) # Expected QALYs under new treatment
ted.cost.Trt <- sum(v.cost.Trt * v.dwc) # Expected costs under new treatment
```


# Cost-effectiveness analysis

```{r CEA-analysis, echo=FALSE}
### Vector of costs
v.ted.cost <- c(ted.cost.UC, ted.cost.Trt)
### Vector of effectiveness
v.ted.qaly <- c(ted.qaly.UC, ted.qaly.Trt)

### Incremental outcomes
delta.C <- v.ted.cost[2] - v.ted.cost[1]  # calculate incremental costs
delta.E <- v.ted.qaly[2] - v.ted.qaly[1]  # calculate incremental QALYs

### ICER
ICER    <- delta.C / delta.E      # calculate the ICER

### Table of outputs
# Create full incremental cost-effectiveness analysis table
table_cea <- data.frame(
  Costs = comma(round(v.ted.cost, 0)),
  QALYs = round(v.ted.qaly, 3),
  `Incremental Costs` = c("-", comma(round(delta.C, 0))),
  `Incremental QALYS` = c("-", round(delta.E, 3)),
  ICER = c("-", comma(round(ICER, 0)))
)
rownames(table_cea) <- v.names.str
colnames(table_cea) <- c("Costs ($)", "QALYs", "Incremental Costs ($)", "Incremental QALYs", "ICER ($/QALY)") # name the columns
```

The results of the cost-effectiveness analysis of the time-dependent Sick-Sicker model are presented in Table \@ref(tab:table-cea). The total expected QALYs for usual care and the new treatment are `r round(ted.qaly.UC, 3)` and `r round(ted.qaly.Trt, 3)`, respectively. The total expected QALYs for usual care and the new treatment are `r dollar(round(ted.cost.UC, 0))` and `r dollar(round(ted.cost.Trt, 0))`, respectively. Under the new treatment, the simulated cohort gets an expected benefit of `r round(delta.E, 3)` QALYs for an additional expected cost of `r dollar(round(delta.C, 0))`. The incremental cost-effectiveness ratio (ICER), defined as the difference in costs divided by the difference in QALYs between the new treatment and usual care, is `r dollar(round(ICER, 0))`/QALY.

```{r table-cea, echo=FALSE, message=FALSE, warning=FALSE}
kable(table_cea, 
      format = ifelse(doc.type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Cost-effectiveness analysis results for the time-dependent Sick-Sicker model",
      align = c("r", "c", "c", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```


# Discussion

In this tutorial, we provide a description on how to implement STCMs for cost-effectiveness analysis using a programming language. We used R as the programming language of choice to show the implementation of these models with accompanying code throughout the tutorial. We describe both time-homogeneous and time-dependent models. We showed two different implementations of the time-dependent model, accounting for transition probabilities that affect the whole cohort at all time (e.g., age-dependency) and for dependency on the amount of time spent in a state (i.e., history-dependent). We provide a mathematical description of these models while connecting it to R code. We focused on discrete-time STCMs but continuous-time models could also be implemented in R. We refer readers interested in learning more on continuous-time STCMs to previously published papers[@Cao2016;@VanRosmalen2013;@Begun2013;@Soares2012] and a tutorial using R.[@Frederix2013a]

Our tutorial has several limitations

STCMs are recommended when the number of states is "not too large"[@Siebert2012c]. This recommendation arises because as the number of states increase, it becomes more difficult to keep track of their construction but not because of the added computational expense. It is possible to build a fairly complex STCMs in R as long as the size of the transition matrix and outputs of interest can be stored in the RAM memory of the computer running the analysis. However, if the required number of state descriptions gets too large and difficult to manage its coding, it becomes preferable to use a stochastic (Monte Carlo) version of the state-transition model --often called microsimulation models-- rather than a cohort simulation model.[@Krijkamp2018]

In summary, this tutorial provides a step-by-step guide to implement STCMs in R. We aim to add to the current body of literature and material on building decision models so health decision scientists are able to develop these models in a more flexible, open-source and transparent manner, and encouraging increased transparency and reproducibility.

# References

