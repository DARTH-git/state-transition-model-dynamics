############################################################################################
### Cohort state-transition models in R: From conceptualization to implementation ## 2018 ##
############################################################################################
# This code forms the basis for the state-transition model of the article: 
# 'Cohort state-transition models in R: From conceptualization to implementation' 
# Authors: 
# Please cite the article when using this code
#
# To program this tutorial we made use of 
# R version 3.4.3 (2017-11-30)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS High Sierra 10.13.2
# RStudio: Version 1.1.383 2009-2017 RStudio, Inc

############################################################################################
################# Code of Appendix A #######################################################
############################################################################################
# Constructs a time-dependent implementation of the Sick-Sicker model embedded in a        #
# function                                                                                 #

##################################### Initial setup ########################################
#rm(list = ls())  # remove any variables in R's memory 
library(dplyr) # to manipulate data
library(reshape2) # to transform data
library(ggplot2) # for nice looking plots
library(scales)  # for dollar signs and commas
library(tensorA) # to use tensor algebra

##################################### Model inputs #########################################
### Function that returns model input parameters
f.params <- function(){
  ## Transition probabilities (per cycle)
  params <- c(
    p.HS1   = 0.15,  # probability to become sick when healthy
    p.S1H   = 0.5,   # probability to become healthy when sick
    p.S1S2  = 0.105, # probability to become sicker when sick
    hr.S1   = 3,     # hazard ratio of death in S1 vs healthy
    hr.S2   = 10,    # hazard ratio of death in S2 vs healthy 
    ## Weibull parameters
    l = 0.08,
    g = 1.1,
    ## State rewards
    # Cost
    c.H   = 2000,  # cost of remaining one cycle healthy 
    c.S1  = 4000,  # cost of remaining one cycle sick 
    c.S2  = 15000, # cost of remaining one cycle sicker 
    c.D   = 0,     # cost of being dead (per cycle)
    c.Trt = 12000, # cost of treatment (per cycle 
    # Utilities
    u.H   = 1.00,     # utility when healthy 
    u.S1  = 0.75,  # utility when sick 
    u.S2  = 0.50,  # utility when sicker
    u.D   = 0.00,  # utility when healthy 
    u.Trt = 0.95,  # utility when being treated
    ## Transition rewards
    du.HS1 = 0.01,  # Disutility when transitioning from H to S1
    ic.HS1 = 1000,  # Increase in cost when transitioning from H to S1
    ic.D   = 1000,  # Increase in cost when dying
    ## Discount factors
    d.e = 0, # 0.03, # Annual discount rate for effectiveness
    d.c = 0 #   # Annual discount rate for costs
  )
  return(params)
}

## Age-dependent mortality rates
lt.usa.2005 <- read.csv("data/LifeTable_USA_Mx_2015.csv")
r.mu <- lt.usa.2005 %>% 
  # filter(Age >= age & Age <= max.age) %>%
  select(Total) %>%
  as.matrix()

################################## State-transition model (STM) #######################################
## Function that constructs and runs a STM by treatment
sick.sicker.stm <- function(params, Trt){
  # Arguments:
  # params: a vector of input parameters of the Sick-Sicker STM
  # Trt:     is this the cohort receiving treatment? (default is FALSE)
  
  with(as.list(params),{
    ## General setup
    age     <- 25         # age at baseline
    max.age <- 55         # maximum age of follow up
    n.t <- max.age - age # time horizon, number of cycles
    v.n <- c("H", "S1", "S2", "D") # the 4 health states of the model:
    # Healthy (H), Sick (S1), Sicker (S2), Dead (D)
    n.s <- length(v.n) # number of health states 
    v.Trt <- c("No Treatment", "Treatment") # store the strategy names
    
    # Discount weight (equal discounting is assumed for costs and effects)
    v.dwe <- v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t)))
    
    ## Tunnels
    tunnel.size <- n.t
    # Sick state
    Sicker.tunnel <- paste("S2_", seq(1, tunnel.size), "Yr", sep = "")
    
    ## Create variables for time-dependent model
    v.n.td  <- c("H", "S1",  Sicker.tunnel, "D") # state names
    n.s.td  <- length(v.n.td)                    # number of states
    
    # Age-specific transition probabilities
    p.HDage  <- 1 - exp(-r.mu[(age + 1) + 0:(n.t-1)]) # age-specific probability of dying
    p.S1Dage <- 1 - exp(-r.mu[(age + 1) + 0:(n.t-1)] * hr.S1)
    
    # Time-dependent disease-specific mortality through a weibull hazard
    r.S2D       <- l*g*(1:tunnel.size)^{g-1}
    p.S2Dage_td <- 1 - exp(-r.mu[(age + 1) + 0:(n.t-1)] * hr.S2)
    
    #### Create age-specific transition matrix ####
    ### Initialize array
    a.P <- array(0, dim = c(n.s, n.s, n.t),
                 dimnames = list(v.n, v.n, 0:(n.t-1)))
    ### Fill in array
    ## From H
    a.P["H", "H", ]  <- 1 - (p.HS1 + p.HDage)
    a.P["H", "S1", ] <- p.HS1
    a.P["H", "D", ]  <- p.HDage
    ## From S1
    a.P["S1", "H", ]  <- p.S1H
    a.P["S1", "S1", ] <- 1 - (p.S1H + p.S1S2 + p.S1Dage)
    a.P["S1", "S2", ] <- p.S1S2
    a.P["S1", "D", ]  <- p.S1Dage
    ## From S2
    a.P["S2", "S2", ] <- 1 - p.S2Dage
    a.P["S2", "D", ]  <- p.S2Dage
    ## From D
    a.P["D", "D", ] <- 1
    
    #### Run Markov model ####
    ## Initial state vector
    # All starting healthy
    s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
    s0
    
    ## Initialize cohort trace for time-dependent (td) STM
    m.M.td <- matrix(0, 
                     nrow = (n.t+1), ncol = n.s, 
                     dimnames = list(0:n.t, v.n))
    # Set first row of M with the initial state vector
    m.M.td[1, ] <- s0
    
    ## Initialize transition array
    a.A <- array(0, 
                 dim = c(n.s, n.s, n.t+1),
                 dimnames = list(v.n, v.n, 0:n.t))
    # Set first slice of A with the initial state vector in its diagonal
    diag(a.A[,, 1]) <- s0
    
    ## Iterate Markov model over time
    for(t in 1:n.t){
      m.M.td[t+1, ] <- m.M.td[t, ] %*% a.P[, , t]
      a.A[,, t+1]   <- m.M.td[t, ] * a.P[,, t]
    }
    
    #### State and Transition Rewards ####
    ### State rewards
    ## Vector of state utilities
    v.u <- c(H  = u.H, 
             # update the utility of sick conditional on treatment:
             S1 = Trt * u.Trt + (1 - Trt) * u.S1, 
             S2 = u.S2, 
             D  = u.D)
    ## Vector of state costs under usual care
    v.c <- c(H  = c.H, 
             # update the cost of sick conditional on treatment
             S1 = c.S1 + c.Trt * Trt, 
             # update the cost of sicker conditional on treatment
             S2 = c.S2 + c.Trt * Trt, 
             D  = c.D)
    
    ### Transition rewards
    ## Matrix of state and transition utilities
    m.u <- matrix(rep(v.u, n.s), 
                  ncol = n.s, byrow = TRUE,
                  dimnames = list(v.n, v.n))
    # Add disutility due to transition from H to S1
    m.u["H", "S1"] <- m.u["H", "S1"] - du.HS1
    
    ## Matrix of state and transition costs
    m.c <- matrix(rep(v.c, n.s), 
                  ncol = n.s, byrow = TRUE,
                  dimnames = list(v.n, v.n))
    # Add transition cost due to transition from H to S1
    m.c["H", "S1"] <- m.c["H", "S1"] + ic.HS1
    # Add transition cost of dying from all non-dead states
    m.c[-n.s, "D"] <- m.c[-n.s, "D"] + ic.D
    
    #### Expected QALYs and Costs per cycle ####
    ## Vector of qalys
    v.qaly <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.u))))
    ## Vector of costs
    v.cost <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.c))))
    
    #### Discounted Total expected QALYs and Costs ####
    te_hat <- v.qaly %*% v.dwe  # total (discounted) QALY 
    tc_hat <- v.cost %*% v.dwc  # total (discounted) cost 
    
    ### Store the results from the simulation in a list  
    results <- list(m.TR = m.M.td, a.A = a.A, 
                    tc_hat = tc_hat, te_hat = te_hat)
    
    ### Return the results
    return(results)  
  }
  )
}

test.ctl <- sick.sicker.stm(params = v.params, Trt = 1)
test.ctl$tc_hat
test.ctl$te_hat

######################################## Run the STM #####################################
## Create vector of input parameters
v.params <- f.params()
## Run model by strategy
sim_markov_no_trt <- sick.sicker.stm(params = v.params, Trt = FALSE) # run for no treatment
sim_markov_trt    <- sick.sicker.stm(params = v.params, Trt = TRUE)  # run for treatement


################################# Cost-effectiveness analysis #############################
# store the mean costs of each strategy in a new variable C (vector costs)
v.C <- c(sim_markov_no_trt$tc_hat, sim_markov_trt$tc_hat) 
# store the mean QALYs of each strategy in a new variable E (vector effects)
v.E <- c(sim_markov_no_trt$te_hat, sim_markov_trt$te_hat)

delta.C <- v.C[2] - v.C[1]            # calculate incremental costs
delta.E <- v.E[2] - v.E[1]            # calculate incremental QALYs
ICER <- delta.C / delta.E             # calculate the ICER
results <- c(delta.C, delta.E, ICER)  # store the values in a new variable

# Create full incremental cost-effectiveness analysis table
table_cea <- data.frame(
  dollar(v.C),              # costs per arm
  round(v.E, 3),            # health outcomes per arm
  c("", dollar(delta.C)),   # incremental costs
  c("", round(delta.E, 3)), # incremental QALYs
  c("", paste0(dollar(ICER), "/QALY"))       # ICER
)
rownames(table_cea) <- v.Trt  # name the rows
colnames(table_cea) <- c("Costs", "QALYs","Incremental Costs", "QALYs Gained", "ICER") # name the columns
table_cea                    # print the table 
