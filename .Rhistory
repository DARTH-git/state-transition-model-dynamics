v.results                    # print the results
### 06 Plot cohort trace
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
ggtitle("Cohort trace of the simple 3-state model")+
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
###############################################################################
### A brief report   ## 2019 ##
################################################################################
# This code forms the basis for the brief report:
# 'An alternative representation of state-transition model dynamics'
# Please cite the article when using this code
################################################################################
# Demonstrate the array approach using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial, we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
## Simple 3-state model showing the array approach ##
# Load the packages
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
# initial set up
age         <- 70  # age of starting cohort
n.t         <- 30  # time horizon, number of cycles
v.age.names <- age:(age + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
#### Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.30   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.15   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### Initial state vector ####
v.m0 <- c(H = 1, S = 0, D = 0) # initiate the vector
v.m0
#### Cohort trace
## Create the Markov cohort trace matrix m.M
## this capturs the proportion of the cohort in each state at each cycle
# initialize cohort trace and the reward matrix for cost and effects
m.M <- m.R.costs <- m.R.effects <- matrix(0,
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
# initiate the array
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- v.m0 # store the initial state vector in the diagonal of A
# Fill in matrix for costs
# From Healthy
m.R.costs["H", "H"]  <- c.H
m.R.costs["H", "S"]  <- c.H
m.R.costs["H", "D"]  <- c.H + ic.D
# From Sick
m.R.costs["S", "H"]  <- c.S
m.R.costs["S", "S"]  <- c.S
m.R.costs["S", "D"]  <- c.S + ic.D
# From Death
m.R.costs["D", "H"]  <- c.D
m.R.costs["D", "S"]  <- c.D
m.R.costs["D", "D"]  <- c.D
# Fill in matrix for effects
# From Healthy
m.R.effects["H", "H"]  <- u.H
m.R.effects["H", "S"]  <- u.H - du.HS
m.R.effects["H", "D"]  <- u.H
# From Sick
m.R.effects["S", "H"]  <- u.S
m.R.effects["S", "S"]  <- u.S
m.R.effects["S", "D"]  <- u.S + ic.D
# From Death
m.R.effects["D", "H"]  <- u.D
m.R.effects["D", "S"]  <- u.D
m.R.effects["D", "D"]  <- u.D
#### Expected QALYs and Costs per cycle for each strategy ####
a.O.costs <- a.O.effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
### Run the model
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
a.A[, , t + 1] <- diag(m.M[t, ]) %*% m.P  # fill array A for t + 1
# element-wise-multiplication of array A with the rewards matrices
a.O.costs[, , t]   <- a.A[, , t] * m.R.costs
a.O.effects[, , t] <- a.A[, , t] * m.R.effects
}
# Perform a cost effectiveness analysis
# calculate the expected costs per cycle
v.costs <- rowSums(t(colSums(a.O.costs)))
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O.effects)))
TC <- sum(v.costs)  # calculate the total expected costs
TE <- sum(v.QALYs)  # calculate the total expected QALYS
v.results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.results) <- c("Costs", "Effect") # name the vector
v.results                    # print the results
### 06 Plot cohort trace
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
ggtitle("Cohort trace of the simple 3-state model")+
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
#### Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# initialize cohort trace and the reward matrix for cost and effects
m.M <- m.R.costs <- m.R.effects <- matrix(0,
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.R.costs
###############################################################################
### A brief report   ## 2019 ##
################################################################################
# This code forms the basis for the brief report:
# 'An alternative representation of state-transition model dynamics'
# Please cite the article when using this code
################################################################################
# Demonstrate the array approach using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial, we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
## Simple 3-state model showing the array approach ##
# Load the packages
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
# initial set up
age         <- 70  # age of starting cohort
n.t         <- 30  # time horizon, number of cycles
v.age.names <- age:(age + n.t - 1) # vector with age names
v.n <- c("H", "S", "D") # vector with the 3 health states of the model:
# Healthy (H), Sick (S), Dead (D)
n.states <- length(v.n) # number of health states
#### Generate initial set of base-case external parameters ####
# Costs
c.H   = 1000   # cost of remaining one cycle healthy
c.S   = 3000   # cost of remaining one cycle sick
c.D   = 0      # cost of being dead (per cycle)
# State utilities
u.H   = 1      # utility when healthy
u.S   = 0.60   # utility when sick
u.D   = 0      # utility when healthy
# Transition probabilities (per cycle)
p.HS  = 0.30   # probability to become sick when healthy
p.HD  = 0.05   # probability to die when healthy
p.SH  = 0.15   # probability to become healthy when sick
p.SD  = 0.20   # probability to die when healthy
# Transition rewards
du.HS  = 0.10  # one-time utility decrement when becoming sick
ic.D   = 4000   # one-time cost of dying
#### Transition probability matrix ####
# matrix m.P at the first cycle
m.P <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix
# From Healthy
m.P["H", "H"]  <- 1 - (p.HS + p.HD)
m.P["H", "S"]  <- p.HS
m.P["H", "D"]  <- p.HD
# From Sick
m.P["S", "H"]  <- p.SH
m.P["S", "S"]  <- 1 - (p.SH + p.SD)
m.P["S", "D"]  <- p.SD
# From Death
m.P["D", "H"]  <- 0
m.P["D", "S"]  <- 0
m.P["D", "D"]  <- 1
#### Initial state vector ####
v.m0 <- c(H = 1, S = 0, D = 0) # initiate the vector
v.m0
#### Cohort trace
## Create the Markov cohort trace matrix m.M
## this capturs the proportion of the cohort in each state at each cycle
# initialize cohort trace matrix
m.M <- matrix(0,
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
# initiate the array
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # initialize array
diag(a.A[, , 1]) <- v.m0 # store the initial state vector in the diagonal of A
m.R.costs <- m.R.effects <- matrix(NA,
nrow = n.states, ncol = n.states,
dimnames = list(v.n, v.n))
# Fill in matrix for costs
# From Healthy
m.R.costs["H", "H"]  <- c.H
m.R.costs["H", "S"]  <- c.H
m.R.costs["H", "D"]  <- c.H + ic.D
# From Sick
m.R.costs["S", "H"]  <- c.S
m.R.costs["S", "S"]  <- c.S
m.R.costs["S", "D"]  <- c.S + ic.D
# From Death
m.R.costs["D", "H"]  <- c.D
m.R.costs["D", "S"]  <- c.D
m.R.costs["D", "D"]  <- c.D
# Fill in matrix for effects
# From Healthy
m.R.effects["H", "H"]  <- u.H
m.R.effects["H", "S"]  <- u.H - du.HS
m.R.effects["H", "D"]  <- u.H
# From Sick
m.R.effects["S", "H"]  <- u.S
m.R.effects["S", "S"]  <- u.S
m.R.effects["S", "D"]  <- u.S + ic.D
# From Death
m.R.effects["D", "H"]  <- u.D
m.R.effects["D", "S"]  <- u.D
m.R.effects["D", "D"]  <- u.D
#### Expected QALYs and Costs per cycle for each strategy ####
a.O.costs <- a.O.effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
### Run the model
for(t in 1:n.t){  # loop through the number of cycles
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 3
a.A[, , t + 1] <- diag(m.M[t, ]) %*% m.P  # fill array A for t + 1
# element-wise-multiplication of array A with the rewards matrices
a.O.costs[, , t]   <- a.A[, , t] * m.R.costs
a.O.effects[, , t] <- a.A[, , t] * m.R.effects
}
# Perform a cost effectiveness analysis
# calculate the expected costs per cycle
v.costs <- rowSums(t(colSums(a.O.costs)))
# calculate the expected QALYs per cycle
v.QALYs <- rowSums(t(colSums(a.O.effects)))
TC <- sum(v.costs)  # calculate the total expected costs
TE <- sum(v.QALYs)  # calculate the total expected QALYS
v.results <- c(TC, TE)       # combine the total expected costs and QALYs
names(v.results) <- c("Costs", "Effect") # name the vector
v.results                    # print the results
### 06 Plot cohort trace
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
ggtitle("Cohort trace of the simple 3-state model")+
theme_bw(base_size = 16) +
scale_x_continuous(name = "Cycles", limits = c(0, n.t), breaks = seq(0, n.t, 10)) +
theme()
################################################################################
# Demonstrate the array appraoch using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.
################################################################################
# To program this tutorial we made use of
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc
################################################################################
rm(list = ls())  # remove any variables in R's memory
###01 Initial setup
#### 01.1 Load packages and functions ####
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas
library(tensorA)  # for tensor calculations
#### 01.1.2 Load functions ####
source("functions/01_model-inputs_functions.R")
source("functions/02_simulation-model_functions.R")
#### 01.1.2 Load functions ####
source("../functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("./functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("/functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("/functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source(".../functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source(".../functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("~/functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("./functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("./functions/01_model-inputs_functions.R")
#------------------------------------------------------#
#### Generate base-case parameters set              ####
#------------------------------------------------------#
f.generate_init_params <- function(){ # User defined
v.params.init <- data.frame(
# Costs
c.H   = 2000,   # cost of remaining one cycle healthy
c.S1  = 4000,   # cost of remaining one cycle sick
c.S2  = 15000,  # cost of remaining one cycle sicker
c.D   = 0,      # cost of being dead (per cycle)
#c.Trt = 12000,  # cost of treatment (per cycle
# State utilities
u.H   = 1,      # utility when healthy
u.S1  = 0.75,   # utility when sick
u.S2  = 0.5,    # utility when sicker
u.D   = 0,      # utility when healthy
#u.Trt = 0.95,  # utility when being treated
# Transition probabilities (per cycle)
p.HS1 = 0.15,   # probability to become sick when healthy
p.S1H = 0.5,    # probability to become healthy when sick
p.S1S2 = 0.105, # probability to become sicker when sick
# Hazard rate ratios
hr.S1  = 3,     # hazard rate ratio of death in S1 vs healthy
hr.S2  = 10,    # hazard rateratio of death in S2 vs healthy
# Transition rewards
du.HS1 = 0.01,  # one-time utility decrement when becoming sick
ic.HS1 = 1000,  # one-time cost of becoming sick
ic.D   = 2000   # one-time cost of dying
)
return(v.params.init)
}
#### 01.1.2 Load functions ####
source("Sick-Sicker case example/functions/01_model-inputs_functions.R")
#### 01.1.2 Load functions ####
source("Sick-Sicker case example/functions/01_model-inputs_functions.R")
source("Sick-Sicker case example/functions/02_simulation-model_functions.R")
#### 01.2 External parameters ####
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("Sick-Sicker case example/data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
### 02 Define and initialize matrices and vectors ####
#### 02.1 Transition probability matrix ####
#### Equation 1 ####
f.create_transition_prob_matrix(v.params = v.params.init, t = 1) # the m.P transition probability matrix at the first cycle
#### 02.2 Initial state vector ####
# The cohort start in the Healthy health state
s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
s0
#### 02.3 Cohort trace
## Create the Markov trace matrix M capturing the proportion of the cohort in each state at each cycle
# Initialize cohort trace
m.M <- matrix(0,
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- s0 # store the initial state vector
#### 03 Matrix Approach    ####
for(t in 1:n.t){  # loop through the number of cycles
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) # create the transition probability matrix for the current cycle
#### Equation 2   ####
m.M[t + 1, ] <- m.M[t, ] %*% m.P  # estimate the state vector for the next cycle (t + 1)
}
head(round(m.M, 3)) # show the first six lines of the Markov trace
#### 04 Array Approach     ####
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t)) # Initialize array
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagnal of A
#### Equation 3  ####
a.A[, , 1]
# run the model
for(t in 1:n.t){                     # loop through the number of cycles
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) # create the transition probability matrix for the current cycle
#### Equation 4    ####
a.A[, , t + 1] <- colSums(a.A[, , t]) * m.P  # fill array A for t + 1
}
#### Equation 5    ####
a.A[, , 2:3] # shown for two cycles
#### Equation 7    ####
# calculating M from A
m.M_A <- t(colSums(a.A))   # sum over the colums of A and transpose
m.M == m.M_A # check if they are exactly the same
#### 05 Apply state and transtion rewards ####
#### 05.1 Create reward matrices for both costs and effects ####
m.R_costs  <- f.create_transition_reward_matrix_costs(v.params = v.params.init)
m.R_effects <- f.create_transition_reward_matrix_effects(v.params = v.params.init)
#### Equation 8   ####
m.R_costs
m.R_effects
#### 05.2 Expected QALYs and Costs per cycle for each strategy ####
#### Equation 9 ####
a.Y_costs <- a.Y_effects <- array(0, dim = c(n.states, n.states, n.t + 1),
dimnames = list(v.n, v.n, 0:n.t))
for(t in 1:n.t){
a.Y_costs[, , t]   <- a.A[, , t] * m.R_costs
a.Y_effects[, , t] <- a.A[, , t] * m.R_effects
}
#### Equation 10 ####
v.Costs <- rowSums(t(colSums(a.Y_costs)))
v.QALYs <- rowSums(t(colSums(a.Y_effects)))
TC <- t(v.Costs) %*% v.dwc
TE <- t(v.QALYs) %*% v.dwe
v.Results <- c(TC, TE)
names(v.Results) <- c("Costs", "Effect")
v.Results # print the results
#### 06 Plot cohort trace  ####
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
geom_line(size = 1.3) +
scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
xlab("Cycle") +
ylab("Proportion of the cohort") +
theme_bw(base_size = 16) +
theme()
knitr::opts_chunk$set(echo = TRUE)
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states
d.c <- 0.03 # discount rate for costs
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("../data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
dplyr::select(Total) %>%
as.matrix()              # vector with mortality rates
#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()
## Create name of parameters
v.names.params <- names(v.params.init)
#### 02.1 Transition probability matrix ####
# matrix m.P at the first cycle
f.create_transition_prob_matrix(v.params = v.params.init, t = 1)
#### 02.2 Initial state vector ####
# the cohort start in the Healthy state
v.m0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
v.m0
#### 02.3 Cohort trace
## Create the Markov cohort trace matrix m.M capturing the proportion of the cohort
# in each state at each cycle
m.M <- matrix(0,  # initialize cohort trace
nrow = (n.t + 1), ncol = n.states,
dimnames = list(0:n.t, v.n))
m.M[1, ] <- v.m0   # store the initial state vector
for(t in 1:n.t){  # loop through the number of cycles
# create the transition probability matrix for the current cycle
m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t)
# estimate the state vector for the next cycle (t + 1)
m.M[t + 1, ] <- m.M[t, ] %*% m.P   # Equation 2
}
