###############################################################################
### A brief report -  ## 2019 ##
################################################################################
# This code forms the basis for the brief report: 
# 'State transition model dynamics TITLE' 
# Authors: 
# Please cite the article when using this code
#
# To program this tutorial we made use of 
# R version 3.5.1 (2018-7-02)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Mojave 10.14
# RStudio: Version 1.1.456 2009-2018 RStudio, Inc

################################################################################
################# Code of Appendix A ###########################################
################################################################################
# Demonstrate the array appraoch using the Sick-Sicker model with age dependent
# transition probabilities but without performing a cost-effectiveness analysis.

################################# Initial setup ################################
#rm(list = ls())  # remove any variables in R's memory 

###01 Initial setup 
#### 01.1 Load packages and functions ####
library(dplyr) # For data manipulation
library(dplyr)    # to manipulate data
library(reshape2) # to transform data
library(ggplot2)  # for nice looking plots
library(scales)   # for dollar signs and commas

#### 01.1.2 Load functions ####
source("functions/01_model-inputs_functions.R")

#### 01.2 External parameters ####
#### 01.2.1 General setup ####
n.age.init  <- 25  # age of starting cohort
n.t         <- 75  # time horizon, number of cycles
v.age.names <- n.age.init:(n.age.init + n.t - 1) # vector with age names
v.n <- c("H", "S1", "S2", "D") # vector with the 4 health states of the model:
# Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n.states <- length(v.n) # number of health states 
d.c <- 0.03 # discount rate for costs 
d.e <- 0.03 # discount rate for QALYs
v.dwc <- 1 / ((1 + d.e) ^ (0:(n.t))) # vector with discount weights for costs
v.dwe <- 1 / ((1 + d.c) ^ (0:(n.t))) # vector with discount weights for QALYs
v.s.init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector

#### 01.2.2 All-cause age-, sex- and race- (ASR) specific mortality ####
df.r.asr <- read.csv("data/01_all-cause-mortality-USA-2015.csv")
v.r.asr  <- df.r.asr %>%
  dplyr::select(Total) %>%
  as.matrix()              # vector with mortality rates

#### 01.2.3 Generate initial set of base-case external parameters ####
v.params.init <- f.generate_init_params()

## Create name of parameters
v.names.params <- names(v.params.init)
## Save base-case set of parameters
write.csv(x = v.params.init, file = "data/01_init-params.csv")


### 02 Define and initialize matrices and vectors ####
#### 02.1.2 Load functions ####
source("functions/02_simulation-model_functions.R")

#### 02.1 Transition probability MATRIX ####
# Equation 1 in the paper 
f.transition_prob_matrix(v.params = v.params.init, t = 1) # the transition probability matrix at the first cycle

#### 02.2 Initial state vector ####
# The cohort start in the Healthy health state
s0 <- c(H = 1, S1 = 0, S2 = 0, D = 0)
s0

#### 02.3 Cohort trace  - Equation 2 in the paper 
## Create the Markov trace matrix M capturing the proportion of the cohort in each state at each cycle
# Initialize cohort trace
m.M <- matrix(0, 
              nrow = (n.t + 1), ncol = n.states, 
              dimnames = list(0:n.t, v.n))

m.M[1, ] <- s0 # store the initial state vector

################################################################################
############################## Matrix approach #################################
################################################################################
#### 03 Run Markov model - Equation 2 in the paper 

for(t in 1:n.t){  # loop through the number of cycles
  m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) # create the transition probability matrix for the current cycle
  m.M[t + 1, ] <- m.M[t, ] %*% m.P  # estimate the state vector for the next cycle (t + 1)
}

head(round(m.M, 3)) # show the first six lines of the Markov trace

################################################################################
############################## Array approach ##################################
################################################################################
# Initialize array
a.A <- array(0, dim = c(n.states, n.states, n.t + 1),
             dimnames = list(v.n, v.n, 0:n.t))

#### 05.1 Run Markov model ####
diag(a.A[, , 1]) <- s0 # store the initial state vector in the diagnal of A

# run the model 
for(t in 1:n.t){                     # loop through the number of cycles
  m.P <- f.create_transition_prob_matrix(v.params = v.params.init, t = t) # create the transition probability matrix for the current cycle
  a.A[, , t + 1] <- colSums(a.A[, ,t]) * m.P  # fill array A for t + 1 
}

a.A[,,1]

# calculating M from A - # Equation 7 in paper 
m.M_A <- t(colSums(a.A))   # sum over the colums of A and transpose 

#### 05.2 Run Markov model ####
# creating both the matrix and array at the same time 
for(t in 1:n.t){                     # loop through the number of cycles
  m.M[t + 1, ]   <- m.M[t, ] %*% m.P # estimate the state vector for cycle t + 1
  a.A[, , t + 1] <- m.M[t, ]  * m.P  # fill array A for t + 1 
}



#### 06 Compute and Plot  ####
#### 06.1 Cohort trace #####
ggplot(melt(m.M), aes(x = Var1, y = value, color = Var2)) +
  geom_line(size = 1.3) +
  scale_color_discrete(l = 50, name = "Health state", h = c(45, 365)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme()


#### 07 Compute Cost-Effectiveness Outcomes ####
#### 07.1 State and transition rewards for each strategy ####
m.R_costs <- f.create_transition_reward_matrix_costs(v.params = v.params.init)
m.R_effect <- f.create_transition_reward_matrix_effects(v.params = v.params.init)


#### 07.2 Expected QALYs and Costs per cycle for each strategy ####
#### Expected QALYs and Costs per cycle ####
## Vector of qalys
v.qaly_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.U_UC))))
## Vector of costs
v.cost_UC  <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.C_UC))))

## Vector of qalys
v.qaly_Tr <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.U_Tr))))
## Vector of costs
v.cost_Tr <- rowSums(t(colSums(to.tensor(a.A) * to.tensor(m.C_Tr))))

#### Discounted Total expected QALYs and Costs ####
te_UC <- v.qaly_UC %*% v.dwe  # total (discounted) QALY 
tc_UC <- v.cost_UC %*% v.dwc  # total (discounted) cost 

te_Tr <- v.qaly_Tr %*% v.dwe  # total (discounted) QALY 
tc_Tr <- v.cost_Tr %*% v.dwc  # total (discounted) cost 


#### Cost-effectiveness analysis ####
### Vector of costs
v.cost <- c(tc_UC, tc_Tr)
### Vector of effectiveness
v.qaly <- c(te_UC, te_Tr)

### Incremental outcomes
delta.C <- v.cost[2] - v.cost[1]             # calculate incremental costs
delta.E <- v.qaly[2] - v.qaly[1]             # calculate incremental QALYs
ICER    <- delta.C / delta.E                 # calculate the ICER
results <- c(delta.C, delta.E, ICER)         # store the values in a new variable

# Create full incremental cost-effectiveness analysis table
table_cstm <- data.frame(
  Costs = dollar(v.cost),
  QALYs = round(v.qaly, 3),
  `Incremental Costs` = c("", dollar(delta.C)),
  `Incremental QALYS` = c("", round(delta.E, 3)),
  ICER = c("", dollar(ICER))
)
rownames(table_cstm) <- v.names.str

table_cstm  # print the table 

